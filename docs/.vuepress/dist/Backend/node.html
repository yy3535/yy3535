<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>node | yy3535</title>
    <meta name="description" content="yy3535的笔记">
    <link rel="icon" href="/img/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.255eb453.css" as="style"><link rel="preload" href="/assets/js/app.22eba307.js" as="script"><link rel="preload" href="/assets/js/7.619225ea.js" as="script"><link rel="prefetch" href="/assets/js/10.3972bd39.js"><link rel="prefetch" href="/assets/js/11.e9366076.js"><link rel="prefetch" href="/assets/js/12.77a3c9a6.js"><link rel="prefetch" href="/assets/js/13.d695eb9b.js"><link rel="prefetch" href="/assets/js/14.e7ac5dcf.js"><link rel="prefetch" href="/assets/js/15.6cad42fc.js"><link rel="prefetch" href="/assets/js/16.b473c6b6.js"><link rel="prefetch" href="/assets/js/17.0b08262f.js"><link rel="prefetch" href="/assets/js/18.be1ec111.js"><link rel="prefetch" href="/assets/js/19.cfcd895e.js"><link rel="prefetch" href="/assets/js/2.94400111.js"><link rel="prefetch" href="/assets/js/20.78f52a86.js"><link rel="prefetch" href="/assets/js/21.65a75fe3.js"><link rel="prefetch" href="/assets/js/22.98662923.js"><link rel="prefetch" href="/assets/js/23.33fdf222.js"><link rel="prefetch" href="/assets/js/24.724d5b30.js"><link rel="prefetch" href="/assets/js/25.1e7eb93c.js"><link rel="prefetch" href="/assets/js/26.0fae35fe.js"><link rel="prefetch" href="/assets/js/27.faef547b.js"><link rel="prefetch" href="/assets/js/28.68b1b0aa.js"><link rel="prefetch" href="/assets/js/29.d1cb8dc1.js"><link rel="prefetch" href="/assets/js/3.65cfa47c.js"><link rel="prefetch" href="/assets/js/30.49f1c154.js"><link rel="prefetch" href="/assets/js/31.9c7abeba.js"><link rel="prefetch" href="/assets/js/32.493be3bc.js"><link rel="prefetch" href="/assets/js/33.2e21bca3.js"><link rel="prefetch" href="/assets/js/34.f5513f01.js"><link rel="prefetch" href="/assets/js/35.c898cd80.js"><link rel="prefetch" href="/assets/js/36.9fe213fc.js"><link rel="prefetch" href="/assets/js/37.c581c8e8.js"><link rel="prefetch" href="/assets/js/38.77cce3c4.js"><link rel="prefetch" href="/assets/js/39.c6b3cd6c.js"><link rel="prefetch" href="/assets/js/4.2ae62931.js"><link rel="prefetch" href="/assets/js/5.9f2898ce.js"><link rel="prefetch" href="/assets/js/6.5116eeab.js"><link rel="prefetch" href="/assets/js/8.5b58253d.js"><link rel="prefetch" href="/assets/js/9.a8870ce8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.255eb453.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.jpg" alt="yy3535" class="logo"> <span class="site-name can-hide">yy3535</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Frontend/" class="nav-link">前端</a></div><div class="nav-item"><a href="/Backend/" class="nav-link router-link-active">后端</a></div><div class="nav-item"><a href="/Operation/" class="nav-link">运维</a></div><div class="nav-item"><a href="/Todo/" class="nav-link">待整理</a></div><div class="nav-item"><a href="https://github.com/yy3535/yy3535" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Frontend/" class="nav-link">前端</a></div><div class="nav-item"><a href="/Backend/" class="nav-link router-link-active">后端</a></div><div class="nav-item"><a href="/Operation/" class="nav-link">运维</a></div><div class="nav-item"><a href="/Todo/" class="nav-link">待整理</a></div><div class="nav-item"><a href="https://github.com/yy3535/yy3535" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>后端</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Backend/node.html" class="active sidebar-link">node</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Backend/node.html#_5-fs应用" class="sidebar-link">5. fs应用</a></li><li class="sidebar-sub-header"><a href="/Backend/node.html#_5-流" class="sidebar-link">5. 流</a></li><li class="sidebar-sub-header"><a href="/Backend/node.html#express" class="sidebar-link">express</a></li><li class="sidebar-sub-header"><a href="/Backend/node.html#websocket" class="sidebar-link">websocket</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="node"><a href="#node" aria-hidden="true" class="header-anchor">#</a> node</h1> <p></p><div class="table-of-contents"><ul><li><a href="#事件环-event-loop">事件环(event loop)</a></li><li><a href="#eventloop-img-事件环-png">!eventloop</a></li><li><a href="#_1-node能够解决什么问题">1. Node能够解决什么问题</a></li><li><a href="#_2-node安装">2. Node安装</a></li><li><a href="#_3-node基础">3. Node基础</a></li><li><a href="#node里的事件环">node里的事件环</a></li><li><a href="#_4-node-module">4. Node Module</a></li></ul></div><p></p> <h3 id="事件环-event-loop"><a href="#事件环-event-loop" aria-hidden="true" class="header-anchor">#</a> 事件环(event loop)</h3> <p>浏览器中，先调用主栈，主栈执行完成后，微任务放入微任务队列，宏任务放入宏任务队列（按执行顺序放入，setTimeout到时间了再放），执行完微任务，再取出宏任务队列中第一个执行，执行完后再次执行完微任务，再取第二个。——环</p> <h3 id><a href="#" aria-hidden="true" class="header-anchor">#</a> <img src="/img/%E4%BA%8B%E4%BB%B6%E7%8E%AF.png" alt="eventloop"></h3> <p>heap:堆，对象引用函数地址放在堆里</p> <p>stack:栈，代码执行放在栈里，后进先出</p> <div class="language- extra-class"><pre class="language-text"><code>//销毁顺序
function a(){
  console.log(1);
  b()
  function b(){
    console.log(2);
    c()
    function c(){
      console.log(3);
    }
  }
}
a()
</code></pre></div><p>queue:队列，先进先出&lt;—— xxx &lt;——</p> <div class="language- extra-class"><pre class="language-text"><code>[1,2,3].shift();
[1,2,3].pop();
</code></pre></div><blockquote><p>什么叫线程？</p> <p>线程里包含着进程。</p></blockquote> <blockquote><p>什么叫进程？</p> <p>计算机分配调度任务的最小单位。</p></blockquote> <p>js是单线程，也可以说是多线程(异步)</p> <p>then方法会比setTimeout等异步的等级更高一些，微任务会优先执行</p> <p><strong>宏任务</strong>： setTimeout setImmediate ie下使用 MessageChannel</p> <p><strong>微任务</strong>： promise.then方法,MutationObserver，nextTick</p> <div class="language- extra-class"><pre class="language-text"><code>setImmediate(function(){})//定时器，只有ie支持，也属于宏任务
let channel=new MessageChannel()//管道，属于宏任务
let port1=channel.port1;
let port2=channel.port2;
port1.postMessage('hello');
port2.onmessage=function(e){
  console.log(e.data)//hello
}



</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let observer=new MutationObserver(function(){
  console.log('当前节点 已经更新完')
})
observer.observe(app,{
  childList:true
});
for(let i=0;i&lt;10;i++){
  app.appendChild(document.createElement('p'));
}
</code></pre></div><h3 id="_1-node能够解决什么问题"><a href="#_1-node能够解决什么问题" aria-hidden="true" class="header-anchor">#</a> 1. Node能够解决什么问题</h3> <ol><li>可用js编写服务端</li> <li>提高用户并发量，比传统的Java和Php高(java多线程)</li></ol> <p>node并不是JavaScript全集(es+dom+bom)，只是ecmascript+模块(服务端必备的方法)</p> <p><img src="/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B.png" alt="屏幕快照 2019-04-06 21.46.45"></p> <ul><li><p>多线程，锁的问题(多个线程修改同一个文件，需要先锁住文件，避免其他线程修改)</p></li> <li><p>多线程，看上去像同时做两件事，但其实只是这个干一点，那个干一点，再这个干一点。切换执行上下文是浪费时间的</p></li> <li><p>i/o密集型业务适合node，node单线程，并且通过事件驱动，完成后自动返回。不像别的是不断地要去询问，完成了吗</p></li></ul> <p>node优点：</p> <ul><li>基于v8引擎，执行效率高，不高的地方用c写，c++模块扩展</li> <li>使用事件驱动，非阻塞式I/O模型</li> <li>npm包管理器，是全球最大的开源库生态系统</li></ul> <p>Node缺点：</p> <p>脆，主线程挂了，就完蛋了</p> <p>node特点：</p> <ol><li><p>单线程(webworker并不能改变单线程的本质)</p> <div class="language- extra-class"><pre class="language-text"><code>//webworker,有任务，去通知别人做，主线程接着运算
//1.js
//不能操作dom
onmessage=function(e){
  let sum=0;
  for(let i=0;i&lt;e.data;i++){
    sum+=i;
  }
  postMessage(sum);
}
//1.html
let worker=new Worker('./1.js');
worker.postMessage(10000);
worker.onmessage=function(e){
  console.log(e.data);
}
console.log('haha')//
</code></pre></div></li> <li><p>浏览器模型</p> <p>我们的代码通过渲染引擎渲染，渲染引擎分为网络引擎，js引擎和css引擎，他们都是不能同时渲染的。都是一个线程。</p> <p><img src="/img/browser.jpg" alt="browser"></p></li> <li><p>node的Event Loop</p> <p>node里没有渲染引擎，只有node系统，功能就是让用户能实现异步。</p> <p>模块里的异步其实是通过多线程模拟实现的。</p> <p><img src="/img/nodesystem.png" alt="nodesystem"></p></li> <li><p>什么场合用node框架</p> <p>不适合处理cpu密集的</p> <ul><li>聊天服务器(websocket)</li> <li>电子商务网站(静态服务，io读取)</li></ul></li></ol> <h3 id="_2-node安装"><a href="#_2-node安装" aria-hidden="true" class="header-anchor">#</a> 2. Node安装</h3> <p>本地：下载安装包直接安装，node -v npm -v(送包管理器)</p> <p>版本切换：mac nvm工具 win下 nvm-win</p> <h3 id="_3-node基础"><a href="#_3-node基础" aria-hidden="true" class="header-anchor">#</a> 3. Node基础</h3> <p>在浏览器中默认this指代window</p> <p>在浏览器中window是代理了global属性</p> <p>而文件中运行这个this不是global</p> <div class="language- extra-class"><pre class="language-text"><code>//1.node.js
console.log(this);//{}
//node文件中打印global
console.log(global)
//Object[global]{
  ...
  global:[Circular],
  process://进程
  	process {
      
  	},
  Buffer://操作文件，需要二进制类型，就是Buffer,可以和字符串进行转换,
  clearImmediate setImmediate
  setTimeout clearTimeout
  ...
}
//把对象展示成详细的
console.dir(Object.keys(global))
</code></pre></div><p>REPL read evaluate print loop 循环求值打印</p> <div class="language- extra-class"><pre class="language-text"><code>node//进入node环境
console.log(this)//打印出global的内容
</code></pre></div><p><strong>全局的属性：</strong></p> <ol><li>console</li></ol> <div class="language- extra-class"><pre class="language-text"><code>console.log('log')
console.log('info') 
process.stdout.write('呵呵')//1 标准输出，等价以上两个
console.warn('warn')
console.error('error')
process.stderr.write('错误')//2 错误输出，等价以上两个
process.stdin.on('data',function(data){
  console.log(data.toString())//0 表示标准输入
})
</code></pre></div><ol start="2"><li><p>process</p> <p>process.pid//进程id</p> <p>process.exit()//手动退出应用</p> <p>process.cwd()//current working directory 当前工作目录</p> <p>process.chdir('6.node')//改变当前工作目录</p> <p>process.nextTick(()=&gt;{//是node中唯一一个微任务</p> <p>​	console.log('nextTick');</p> <p>})</p> <p>process 环境变量 env 参数 argv：webpack definePlugin原理就是通过这个实现</p> <div class="language- extra-class"><pre class="language-text"><code>//yargs把执行命令的时候传递参数解析成对象，可以自己手动将其变成对象
let args=process.argv.slice(2);
args=args.reduce((total,value,currentIndex,arr)=&gt;{
  if(value.includes('-')){
    total[value.slice(1)]=arr[currentIndex+1];
  }
  return total;
},{});
console.log(args.p)
</code></pre></div><blockquote><h3 id="node里的事件环"><a href="#node里的事件环" aria-hidden="true" class="header-anchor">#</a> node里的事件环</h3> <p>node中有如下六个队列，依次执行。</p> <p>每次都把队列清空后，或者达到执行的最大限制切换到下一个队列中会再执行微任务</p></blockquote> <p><img src="/img/node%E4%BA%8B%E4%BB%B6%E7%8E%AF.png" alt="node事件环"></p> <blockquote><p>面试题：</p> <div class="language- extra-class"><pre class="language-text"><code>let fs=require('fs');
//poll阶段下一个阶段是check,所以执行的话一定是走的setImmidaite
fs.readFile('note.md','utf-8',function(){
  setTimeout(function(){
    console.log('timeout')
  },0);
  setImmediate(function(){
    console.log('setImmediate2')
  })
})
</code></pre></div></blockquote></li></ol> <h3 id="_4-node-module"><a href="#_4-node-module" aria-hidden="true" class="header-anchor">#</a> 4. Node Module</h3> <p>模块，解决协同开发问题，避免全局变量，防止崇明，模块化都是靠闭包实现的。</p> <p>cmd:sea.js</p> <p>amd:require.js</p> <p>node里用common.js</p> <ul><li><p>定义模块 node中一个文件就是一个模块</p></li> <li><p>引用模块 require静态导入，</p> <blockquote><p>esmodule: 即es6模块 使用import 动态导入</p></blockquote> <p>node靠文件读取</p> <div class="language- extra-class"><pre class="language-text"><code>//1.js
module.export=&quot;zfpx&quot;
//2.module.js
//读取文件
let str=require('./1.js')
console.log(str);
let r=require('./user')//会默认添加后缀名.js，找不到再.json，找不到再.node
//内置模块

</code></pre></div></li> <li><p>导出模块 module.exports</p></li></ul> <p><strong>模块化原理</strong></p> <blockquote><p>seajs requirejs 闭包</p> <p>node也是为了模块化，所以在每个文件外面套了个闭包，这个函数把文件中的this指向更改为module.exports</p> <div class="language- extra-class"><pre class="language-text"><code>(function (exports,require,module,__filename,__dirname){
  module.exports='zfpx';
  return module.exports//隐藏了这句
})
let fn=`(function a(){let b=1;console.log(b)})()`;
//内置模块 沙箱
let vm=require('vm');
vm.runInThisContext(fn);
</code></pre></div></blockquote> <p><strong>node内置方法</strong></p> <ol><li><p>vm沙箱</p> <p>vm.runInThisContext(fn) 在当前沙箱中运行fn代码</p></li> <li><p>fs沙箱</p> <p>fs.accessSync(文件名) 判断文件是否可以访问的到</p> <p>Fs.readfile() 读取文件</p> <div class="language- extra-class"><pre class="language-text"><code>let fs=require('fs');
fs.accessSync('1.test.js')
</code></pre></div></li> <li><p>path 相对路径转绝对路径</p> <p>path.resolve(目录,文件名)在目录下找文件</p> <p>path.join(目录,文件名)拼接，与resolve唯一不同处在遇到/的时候，resolve会返回最上层目录</p> <p>path.extname('1.min.js') //取扩展名 .js</p> <p>path.basename('1.min.js','.js')//取基础名 1.min</p> <div class="language- extra-class"><pre class="language-text"><code>let path=require('path');
console.log(path.resolve('1.test.js'))//C:\Users\speedly\...
console.log(path.resolve(__dirname,'1.test.js'))//__dirname下的1.test.js
console.log(path.join(__dirname,'1.test.js'))//与上面一样
console.log(path.resolve('a','/'))//resolve一碰到/就会返回最上层目录	c:\
console.log(path.join('a','/'))//a/
path.basename('1.min.js','.min.js')//取基础名 1
</code></pre></div></li></ol> <p><strong>require原理</strong>(加载js如何实现)</p> <p>拿到用户传入的路径将路径解析成绝对路径，创建一个模块，根据路径加载对应的方法，如果是json把读取的结果放到模块的exports对象上，req方法最后返回这个exports对象</p> <div class="language- extra-class"><pre class="language-text"><code>//核心模块 不需要./操作
let path=require('path');
let fs=require('fs');
let vm=require('vm');
function Module(id){
  this.id=id;
  this.exports={};//导出对象
}
let obj={
  '.js'(module){
    let content=fs.readFileSync(module.id,'utf8');
    let moduleWrap=['(function(exports,module,require,__filename,__dirname){','})'];
    //给字符串添加了一个函数
    let script=moduleWrap[0]+content+moduleWrap[1];
    vm.runInThisContext(script).call(module.exports,module.exports,module,req);
  },
  '.json'(module){//处理json的模块
    module.exports=JSON.parse(fs.readFileSync(module.id,'utf8'))
  }
}
function req(moduleId){
	//拿到绝对路径
  let absPath=path.resolve(__dirname,moduleId);
  //创建模块
  let module=new Module(absPath);
  //根据后缀名进行加载
  let ext=path.extname(absPath);
  //加载json 加载完后expots会赋予最终的结果，并把结果返回
  obj[ext](module);
  return module.exports;
}

let user=req('./user.json');
console.log(user);
let user=req('./user.js');
console.log(user);
</code></pre></div><blockquote><p><strong>面试题</strong></p> <p>module和exports什么关系？</p> <p>答：exports是module.exports的别名</p></blockquote> <p><strong>module.exports的两种写法</strong></p> <ul><li>module.exports=xxx</li> <li>export.a=xxx</li> <li>global.b=xxx//引用时也是global.b//不推荐，一般不使用</li></ul> <p>exports=module.exports={}</p> <p>所以不能直接赋值exports，因为返回的是module.exports，但可以赋值给exports.a属性值也会添加到module.exports身上</p> <p><strong>第三方模块</strong></p> <p>下载别人的包来使用npm</p> <p>npm.js.org</p> <p>安装有两种方式：</p> <ul><li><p>全局安装</p> <p>npm install xxx -g 只能在命令行中使用，工具类的会用这种方式</p> <p>统一安装到 C:\Users\speedly\AppData\Roaming\npm\node_modules</p> <p>(并不是像node和npm一样配置到环境变量里，而是在npm目录下创建了快捷键，所以能直接使用)</p> <div class="language- extra-class"><pre class="language-text"><code>npm install nrm -g//切换npm下载源
sudo npm install nrm -g(mac版)
nrm --help//查看使用方法
nrm ls //列出所有源
npm 官方 cnpm 中国 taoboa 淘宝的
nrm use npm//切到npm

npm install http-server -g//启动一个服务

npm root -g//查看全局安装的安装目录
</code></pre></div></li> <li><p>本地安装</p> <p>先初始化(node package manager)：npm init -y</p> <p>npm install jquery 默认是项目依赖(上线开发都需要，install可简写成i)</p> <p>npm install @babel/cli -D 开发的时候使用，上线不用</p> <p>npm install jquery@2.1.0//选择版本</p> <p>Npm uninstall jquery//卸载</p> <div class="language- extra-class"><pre class="language-text"><code>npm info react//查看
</code></pre></div><p>yarn也是一个包管理工具 区别：比npm快</p> <p>npm install yarn -g</p> <p>yarn add jquery</p> <p>yarn remove jquery</p> <p>yarn add jquery -D//安装成开发依赖(与npm一样)</p></li></ul> <p><strong>模块查找流程</strong></p> <p><img src="/img/commonjs%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E9%80%BB%E8%BE%91%E5%9B%BE" alt></p> <p>module.paths:(模块的所有路径，当前路径找不到，就往上找)</p> <div class="language- extra-class"><pre class="language-text"><code>[ '/Users/yinyi/test/node_modules',
  '/Users/yinyi/node_modules',
  '/Users/node_modules',
  '/node_modules' ]
</code></pre></div><ul><li>当前node_modules下，如果有文件同名js，先走js，找不到再找index.js，</li> <li>有文件先找文件，没有文件再找文件夹//node10以上</li> <li>自己写的模块也一样。</li></ul> <p><strong>node核心模块</strong></p> <ol><li><p>util 工具方法</p> <p>util.promisify(xxx)//将回调方法改成promise</p> <div class="language- extra-class"><pre class="language-text"><code>let util=require('util');//拿出来是个属性实例
let fs=require('fs');
let read=util.promisify(fs.readFile);
</code></pre></div><blockquote><p><strong>util较麻烦，一般用第三方模块mz，将node模块转化成promise形式</strong></p> <div class="language- extra-class"><pre class="language-text"><code>let fs=require('mz/fs');
</code></pre></div></blockquote> <p>Util.inherits();//继承方法，构造函数，继承原型上的属性(公有属性)</p> <div class="language- extra-class"><pre class="language-text"><code>//原理
Object.setPrototypefOf()
</code></pre></div></li> <li><p>events 自定义事件</p> <p>node主要靠事件驱动(发布订阅模式，vue，redux都是)</p> <p>girl.on//绑定</p> <p>girl.emit('失恋')//调用</p> <p>girl.on('newListener',function(type){})//新增绑定后调用,type是当前事件名称</p> <p>girl.removeListener/off('失恋',cry)//解除绑定</p> <p>girl.defaultMaxListeners//默认最大绑定数</p> <p>girl.setMaxListener(1)//设置最大绑定数</p> <p>girl.once('失恋',cry)//不管绑定多少次，仅触发一次</p> <div class="language- extra-class"><pre class="language-text"><code>let EventEmitter=require('events');//拿出来是个类
let util=require('util');
function Girl(){
  
}
util.inherits(Girl,EventEmitter);
girl.on('newListener',function(type){
  console.log(type)
  girl.emit('失恋')
})
let cry=function(){console.log('cry')}
let eat=function(){console.log('eat')}
girl.on('失恋',cry);
girl.on('失恋',eat);
</code></pre></div><p><strong>原理：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>function EventEmitter(){
  this._events=Object.create(null)
}
EventEmitter.prototype.prependListener=function(eventName,callback){
  this.on(eventName,callback,true);
}
EventEmitter.prototype.on=function(eventName,callback,flag){
  if(!this._events) this._events=Object.create(null);
  if(eventName!='newListener'){
    this._events[newListener].forEach((fn)=&gt;{
      fn(eventName)
    });
  }
  if(this._events[eventName]){
  	if(falg){
      this._events[eventName].unshift(callback);
  	}else{
      this._events[eventName].push(callback);
  	}
    
  }else{
    this._events[eventName]=[callback];
  }
}
EventEmitter.prototype.off=function(eventName,callback){
	//当前函数绑定的是cry,删除的也是cry
  this._events[eventName]=this._events[eventName].filter(
  (l)=&gt;l!=callback&amp;&amp;l.l!=callback)
}
EventEmitter.prototype.once=function(eventName,callback){
	function one(...args){
		callback(...args)
    this.off(eventName,one)
	}
	one.l=callback;
  this.on(eventName,one);
}
Emitter.prototype.emit=function(eventName,...args){
  this._events[eventName].forEach(fn=&gt;{
    fn.call(this,...args);
  })
}
module.exports=EventEmitter;
</code></pre></div></li></ol> <h2 id="_5-fs应用"><a href="#_5-fs应用" aria-hidden="true" class="header-anchor">#</a> 5. fs应用</h2> <blockquote><p>编码</p> <ul><li><p>node为了能操作文件，提供了fs模块，(文件内容一般都是二进制，八进制，十六进制），node读取的结果默认为十六进制</p></li> <li><p>一个字节最大是255位 0xff，</p></li> <li><p>汉字和字母占字节数</p> <p>看编码 utf8 三个字节 1个字节</p> <p>编码历史</p> <ol><li>ASCll码，最早美国人发明，包括127位英文字母在内的各种字符，所以一个英文字母占一位。但是对汉字和其他语言无效。</li> <li>GB2312，其他国家把128-255改成他们的字符，中国也改成了自己的字符，规定两个大于127的字符连一起就表示一个汉字，可以组合出7998个简体汉字，把数字符号，日文假名和ASCll原来就有的数字、标点、字母重编成两个字长的编码叫做全角字符。这种方案叫GB2312，是对ASCll的中文扩展。后来因为我们也得用法语，德语等其他语言，所以不用了。</li> <li>GBK，因为GB2312不够用，规定只要第二个字符大于127就是汉字，增加了20000个新汉字，包括繁体字和符号。</li> <li>GB18030/DBCS 增加了少数名字的字。</li> <li>Unicode，包括了地球上所有文化，所有字母和符号的编码，现在的规模可以容纳100多万个符号。规定所有的字母和符号都是两个字节。</li> <li>UTF-8，是Unicode的实现方式之一，是在互联网上使用最广的一种，意思是每次以8个单位传输数据，UTF-16就是以每次16位传输数据，UTF-8一个中文字符占3个字节。(node不支持gbk)</li></ol> <p>编码转换(base64)</p> <ol><li>图片转base64，不会发生请求</li> <li>简单的编码转换，没有加密功能，把原有体积扩大了1/3</li> <li>fileReader文件读取器，读成base64编码的</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;input type=&quot;file&quot; onchange=&quot;fn(event)&quot; /&gt;
&lt;script&gt;
	function fn(e){
    let reader=new FileReader();
    reader.readAsDataURL(e.target.files[0]);
    reader.onload=function(e){
      console.log(e.currentTarget.result)
    }
	}
&lt;/script&gt;
</code></pre></div><p>进制转换</p> <p>().toString(进制)，任意进制转换</p> <p>parseInt('1011',2) 将任何进制转成十进制</p> <div class="language- extra-class"><pre class="language-text"><code>//十进制转化成二进制
(11).toString(2)
</code></pre></div><p>Buffer</p> <div class="language- extra-class"><pre class="language-text"><code>let buf1=Buffer.alloc(12)
let buf2=Buffer.from('珠峰')
</code></pre></div><p>buf2.toString()//珠峰</p> <p>buf1.from([1，2，3])//把数组和字符串转换成二进制</p> <p>buf1.alloc(3)//通过数字声明一个buffer，3是字节长度</p> <p>buf1.forEach()//循环</p> <p>buf2.copy(buf1,targetStart,sourceStart,sourceEnd)//复制</p> <p>Buffer.concat([buf1,buf2])//拼接</p> <p>buf2.indexOf('珠')</p></li></ul></blockquote> <p>fs将文件读取成buffer。</p> <p>fs方法中，一般会有同步和异步两种方法，同步可以马上拿到返回结果，异步通过callback，只能error-first来获取错误。一般采用异步的方式。</p> <p>{encoding:'utf8',flag:'r'}</p> <p>flags:</p> <table><thead><tr><th>符号</th> <th>含义</th></tr></thead> <tbody><tr><td>r</td> <td>读文件，文件不存在报错</td></tr> <tr><td>r+</td> <td>读取并写入，文件不存在报错</td></tr> <tr><td>w</td> <td>写入文件，不存在则创建，存在则清空</td></tr> <tr><td>w+</td> <td>读取并写入文件，不存在则创建，存在则清空</td></tr> <tr><td>wx</td> <td>排它写入文件</td></tr> <tr><td>a</td> <td>追加写入</td></tr></tbody></table> <ol><li><p>fs.readFile//读取文件</p> <div class="language- extra-class"><pre class="language-text"><code>fs.readFile('./note.md','utf8',function(err,data){
	if(err){
		console.log(err);
	}
	console.log(data);
})
//{encoding:'utf8',flags:'r'}
</code></pre></div></li> <li><p>fs.writeFile//写入文件</p> <p>写入时，文件不存在会创建文件，如有内容会清空内容</p> <div class="language- extra-class"><pre class="language-text"><code>fs.writeFile('./note.md',1,function(err,data){
	if(err){
		console.log(err);
	}
	console.log(data);
})
</code></pre></div><p><strong>拷贝功能：</strong></p> <p>readfile将内容整个读取到内存中，再写入文件中。所以这种方式不可能读取比内存大的文件</p> <div class="language- extra-class"><pre class="language-text"><code>function copy(source,target){
  fs.readFile(source,function(err,data){
    fs.writeFile(target,data,function(err){
      console.log('成功')
    })
  })
}
copy('a.md','b.md')
</code></pre></div></li> <li><p>fs.appendFile //追加写入</p> <p>里面使用flag:a</p></li> <li><p>fs.copyFile//拷贝文件</p> <div class="language- extra-class"><pre class="language-text"><code>fs.copyFile(source,target,function(){
  console.log('ok')
})
</code></pre></div></li> <li><p>从指定位置开始读取文件</p> <ul><li><p>打开文件：fs.open('./1,txt','r',0600,<strong>function</strong>(err,fd){});</p></li> <li><p>读取文件：fs.read(fd, buffer, offset, length, position, callback((err, bytesRead, buffer)))</p></li> <li><p>写入文件：fs.write(fd, buffer[, offset[, length[, position]]], callback)</p></li></ul> <blockquote><p>process.stdin 0</p> <p>process.stdout 1</p> <p>process.stderr 2</p> <p>0,1,2是标识符，node中默认会占用0,1,2十三个描述符，所以自定义fd的是从3开始数</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>/*打开文件*/
fs.open('a.md','r',function name(err,fd){
  console.log(fd)//3,fd是标识符，每次打开会累加
  let buffer=Buffer.alloc(3);//只能放三勺水
  /*读取文件*/
  //fd 文件描述符 buffer读取到哪里
  //0 是从buffer的哪个位置读取
  //3 读取的个数
  //0 读取文件的位置
  fs.read(fd,buffer,0,3,0,function(err,bytesRead){
  	//bytesRead 真实读取的字节数 &lt;Buffer 31 00 00&gt;
    /*关闭文件*/
    fs.close(fd,()=&gt;{
      console.log('关闭')
    })
  })
})
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>/*打开文件*/
fs.open('a.md','w',function(err,fd){
	let buffer=Buffer.from([1,2,3,4])
	/*写入文件*/
	//fd 代表文件描述符
	//0 代表把buffer的第几个位置开始写入
	//2 代表写入的个数
	//0 写到文件的哪个位置
  fs.write(fd,buffer,0,2,0,function(err,written){
    console.log('写入成功')
    fs.fsync();//最后应该调用此方法，更新内存，将文件写入到磁盘中。
  });
})
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//实现一个拷贝，用fs.open fs.read fs.write实现拷贝文件的功能，控制读取速率，防止内存占用过多
//第三个参数写Null，就会自动往后，不用自己计算位置
//流的原理，发布订阅来简化
function copy(source,target,callback){
  const BufferSize=2;
  fs.open(source,'r',function(err,rfd){
    fs.open(target,'w',function(err,wfd){
    	let buffer=Buffer.aloc(3);
    	function next(){
        fs.read(rfd,buffer,0,BUFFERSIZE,null,function(err,bytesRead){
          if(bytesRead&gt;0){
            fs.write(wfd,buffer,0,bytesRead,null,function(err,written){
              next();
            });
          }else{
          	fs.close(rfd,()=&gt;{})
          	fs.close(wfd,()=&gt;{
              fs.fsync();
          	})
            callback();
          }
        })
    	};
    	next();
    })
  })
}
copy('a.md','b.md',function(){
  console.log('复制成功')
})
</code></pre></div></li> <li><p>direction</p> <div class="language- extra-class"><pre class="language-text"><code>//创建目录(必须保证父级存在)
fs.mkdirSync('a/b') 或者fs.mkdirSync('a/b/c')或者 fs.mkdirSync('a\\b')双杠为了转义成\
fs.mkdir()
//判断一个文件是否有权限访问
fs.access(path[, mode], callback)
//删除目录(必须保证目录中没有子文件和子文件夹，否则会出错)
fs.rmdirSync('a')
fs.rmdir('a')
//删除文件
fs.unlinkSync
fs.unlink
//读取目录下所有文件
fs.readdir(path[, options], callback)
//查看文件目录信息
let stat=fs.statSync(path)
let stat=fs.stat(path,callback)
stat.isDirectory()//是否是目录
stat.isFile()//是否是目录
</code></pre></div><blockquote><p>做一个创建任意目录的工具</p> <div class="language- extra-class"><pre class="language-text"><code>let fs=require('fs');
//同步,使用for循环
function mkdirSync(p){
  let dirs=p.split('/');
  for(let i=0;i&lt;dirs.length;i++){
  	let currentPath=dirs.slice(0,i).join('/');
  	try{
      fs.accessSync(currentPath);
  	}catch(e){
      fs.mkdirSync(currentPath);
  	}
  }
}
mkdirSync('m/q/d')

//异步，使用递归，next方法来帮助进行迭代操作
//fs.access
function mkdir(p,callback){
  let dirs=p.split('/');
  let index=0;
  function next(){
  	if(index===dirs.length) return callback();
    let currentPath=dirs.slice(0,++index).join('/');
    fs.access(currentPath,function(err){
      if(err){
        fs.mkdir(currentPath,function(){
          next();
        });
      }else{
        next();//当前文件夹存在就继续迭代
      }
    })
  }
  next();
}
mkdir('a/b/c',function(){
  console.log('创建完成')
})
</code></pre></div></blockquote> <blockquote><p>同步先序深度优先删除目录</p> <div class="language- extra-class"><pre class="language-text"><code>let fs=require('fs');
let path=require('path')
function rmSync(dir) {
    try {
        let stat = fs.statSync(dir);
        if (stat.isFile()) {
            fs.unlinkSync(dir);
        } else {
            let files=fs.readdirSync(dir);
            files
                .map(file =&gt; path.join(dir,file))
                .forEach(item=&gt;rmSync(item));
            fs.rmdirSync(dir);
        }
    } catch (e) {
        console.log('删除失败!');
    }
}
rmSync(path.join(__dirname,'a'));
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//异步串行删除目录深度优先
function rmAsyncSeries(dir,callback) {
    setTimeout(() =&gt; {
        fs.stat(dir,(err,stat) =&gt; {
            if (err) return callback(err);
            if (stat.isDirectory()) {
                fs.readdir(dir,(err,files) =&gt; {
                    let paths = files.map(file =&gt; path.join(dir,file));
                    function next(index) {
                        if (index&gt;=files.length) return fs.rmdir(dir,callback);
                        let current=paths[index];
                        rmAsyncSeries(current,()=&gt;next(index+1));
                    }
                    next(0);
                });
            } else {
                fs.unlink(dir,callback);
            }
        })
    },1000);
}

console.time('cost');
rmAsyncSeries(path.join(__dirname,'a'),err =&gt; {
     console.timeEnd('cost');
})

//异步并行删除目录深度优先
function rmAsyncParallel(dir,callback) {
    setTimeout(() =&gt; {
        fs.stat(dir,(err,stat) =&gt; {
            if (err) return callback(err);
            if (stat.isDirectory()) {
                fs.readdir(dir,(err,files) =&gt; {
                    let paths=files.map(file =&gt; path.join(dir,file));
                    if (paths.length&gt;0) {
                        let i=0;
                        function done() {
                            if (++i == paths.length) {
                                fs.rmdir(dir,callback);
                            }
                        }
                      paths.forEach(p=&gt;rmAsyncParallel(p,done));
                    } else {
                        fs.rmdir(dir,callback);
                    }
                });
            } else {
                fs.unlink(dir,callback);
            }
        })
    },1000);
}
console.time('cost');
rmAsyncParallel(path.join(__dirname,'a'),err =&gt; {
     console.timeEnd('cost');
})

//异步删除非空目录(Promise版)
function rmPromise(dir) {
    return new Promise((resolve,reject) =&gt; {
        fs.stat(dir,(err,stat) =&gt; {
            if (err) return reject(err);
            if (stat.isDirectory()) {
                fs.readdir(dir,(err,files) =&gt; {
                    let paths = files.map(file =&gt; path.join(dir,file));
                    let promises = paths.map(p=&gt;rmPromise(p));
                    Promise.all(promises).then((() =&gt; fs.rmdir(dir,resolve)));
                });
            } else {
                fs.unlink(dir,resolve);
            }
        });
    });
}
rmPromise(path.join(__dirname,'a')).then(() =&gt; {
    console.log('删除成功');
})

//同步删除目录(广度优先) 
function rmSync(dir){
    let arr=[dir];
    let index=0;
    while (arr[index]) {
        let current=arr[index++];
        let stat=fs.statSync(current);
        if (stat.isDirectory()) {
            let dirs=fs.readdirSync(current);
            arr=[...arr,...dirs.map(d =&gt; path.join(current,d))];
        }
    }
    let item;
    while (null != (item = arr.pop())) {
        let stat = fs.statSync(item);
        if (stat.isDirectory()) {
            fs.rmdirSync(item);
        } else {
            fs.unlinkSync(item);
        }
    }
}

//异步删除目录(广度优先)
function rmdirWideAsync(dir,callback){
    let dirs=[dir];
    let index=0;
    function rmdir() {
        let current = dirs.pop();
        if (current) {
            fs.stat(current,(err,stat) =&gt; {
                if (stat.isDirectory()) {
                    fs.rmdir(current,rmdir);
                } else {
                    fs.unlink(current,rmdir);
                }
            });
        }
    }
    !function next() {
        let current=dirs[index++];
        if (current) {
            fs.stat(current,(err,stat) =&gt; {
                if (err) callback(err);
                if (stat.isDirectory()) {
                    fs.readdir(current,(err,files) =&gt; {
                        dirs=[...dirs,...files.map(item =&gt; path.join(current,item))];
                        next();
                    });
                } else {
                    next();
                }
            });
        } else {
            rmdir();
        }
    }();
}
</code></pre></div></blockquote></li></ol> <h2 id="_5-流"><a href="#_5-流" aria-hidden="true" class="header-anchor">#</a> 5. 流</h2> <p>直接读取文件会占用内存。而流会从一个位置读到另一个位置，不关心内存大小。原理是封装了fs.read等。</p> <p>Node.js中<strong>四种基本的流类型</strong>：</p> <ul><li>可读流，可写流，可读写流(双工流)，读写过程中可修改和变换数据的Duplex流</li></ul> <ol><li><p>可读流</p> <ol><li><p>创建</p> <p>fs.createReadStream(path,[options]);</p></li></ol> <ul><li><p>path读取文件的路径</p></li> <li><p>options</p> <ul><li>flags打开文件要做的操作,默认为'r'</li> <li>encoding默认为null</li> <li>autoClose:默认true</li> <li>start开始读取的索引位置</li> <li>end结束读取的索引位置(包前包后)</li> <li><strong>highWaterMark</strong>每次读取缓存区默认的大小64kb</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>var rs = fs.createReadStream(path,[options]);
</code></pre></div><ol start="2"><li><p>监听data事件</p> <div class="language- extra-class"><pre class="language-text"><code>rs.on('data', function (data) {
    console.log(data);
});
</code></pre></div></li> <li><p>监听end事件</p> <div class="language- extra-class"><pre class="language-text"><code>rs.on('end', function () {
    console.log('读取完成');
});
</code></pre></div><blockquote><p>所有事件都是内部发布，外部on订阅。</p></blockquote></li> <li><p>监听open事件</p> <div class="language- extra-class"><pre class="language-text"><code>rs.on('open', function () {
    console.log(err);
});
</code></pre></div></li> <li><p>监听close事件</p> <div class="language- extra-class"><pre class="language-text"><code>rs.on('close', function () {
    console.log(err);
});
</code></pre></div></li> <li><p>监听错误事件(文件不存在)</p> <div class="language- extra-class"><pre class="language-text"><code>rs.on('error', function (err) {
    console.log(err);
});
</code></pre></div></li> <li><p>暂停和恢复触发data</p> <p>通过pause()方法和resume()方法</p> <div class="language- extra-class"><pre class="language-text"><code>rs.on('data', function (data) {
    rs.pause();
    console.log(data);
});
setTimeout(function () {
    rs.resume();
},2000);
</code></pre></div></li></ol></li> <li><p>可写流</p></li> <li><p>pipe方法</p></li> <li><p>简单实现原理</p></li> <li><p>暂停模式</p></li> <li><p>自定义可读流</p></li></ol> <h2 id="express"><a href="#express" aria-hidden="true" class="header-anchor">#</a> express</h2> <ul><li>安装</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>npm install <span class="token operator">-</span>g express<span class="token operator">-</span>generator
npm install <span class="token operator">-</span>g express
</code></pre></div><ul><li>快速创建express项目</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// e.js作为模板引擎</span>
express <span class="token operator">-</span>e <span class="token punctuation">.</span><span class="token operator">/</span>
</code></pre></div><ul><li>使用</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//server.js</span>
<span class="token keyword">let</span> express<span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> app<span class="token operator">=</span><span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/getUser'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'zfpx'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="websocket"><a href="#websocket" aria-hidden="true" class="header-anchor">#</a> websocket</h2> <ul><li>安装</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>npm i nodejs<span class="token operator">-</span>websocket <span class="token operator">-</span><span class="token constant">S</span>
</code></pre></div><ul><li>创建服务使用</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> ws <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;nodejs-websocket&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;开始建立连接...&quot;</span><span class="token punctuation">)</span>

<span class="token keyword">var</span> server <span class="token operator">=</span> ws<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">conn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  conn<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;text&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> msg <span class="token operator">=</span> <span class="token punctuation">{</span>
        type<span class="token punctuation">:</span> <span class="token string">&quot;message&quot;</span><span class="token punctuation">,</span>
        text<span class="token punctuation">:</span> <span class="token string">&quot;something&quot;</span><span class="token punctuation">,</span>
        id<span class="token punctuation">:</span>   <span class="token string">&quot;number&quot;</span><span class="token punctuation">,</span>
        date<span class="token punctuation">:</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;message:&quot;</span><span class="token operator">+</span>str<span class="token punctuation">)</span>
    conn<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  conn<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;close&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">code<span class="token punctuation">,</span> reason</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;关闭连接&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  conn<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;error&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">code<span class="token punctuation">,</span> reason</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;异常关闭&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3001</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;WebSocket建立完毕&quot;</span><span class="token punctuation">)</span>
</code></pre></div></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">5/30/2019, 4:59:43 PM</span></div></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.22eba307.js" defer></script><script src="/assets/js/7.619225ea.js" defer></script>
  </body>
</html>
