<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue | yy3535</title>
    <meta name="description" content="yy3535的笔记">
    <link rel="icon" href="/img/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.9cd8b68b.css" as="style"><link rel="preload" href="/assets/js/app.14dbe886.js" as="script"><link rel="preload" href="/assets/js/24.f0f70b8c.js" as="script"><link rel="prefetch" href="/assets/js/10.53163a34.js"><link rel="prefetch" href="/assets/js/11.71698fa7.js"><link rel="prefetch" href="/assets/js/12.3aa598ee.js"><link rel="prefetch" href="/assets/js/13.8d3e5c2b.js"><link rel="prefetch" href="/assets/js/14.16087bb3.js"><link rel="prefetch" href="/assets/js/15.338312c2.js"><link rel="prefetch" href="/assets/js/16.9e690ae9.js"><link rel="prefetch" href="/assets/js/17.2192cdae.js"><link rel="prefetch" href="/assets/js/18.28fa6872.js"><link rel="prefetch" href="/assets/js/19.609bd761.js"><link rel="prefetch" href="/assets/js/2.066c3c73.js"><link rel="prefetch" href="/assets/js/20.558b8601.js"><link rel="prefetch" href="/assets/js/21.9cd1db22.js"><link rel="prefetch" href="/assets/js/22.75f5ffe8.js"><link rel="prefetch" href="/assets/js/23.60d8f0b6.js"><link rel="prefetch" href="/assets/js/25.a2f69063.js"><link rel="prefetch" href="/assets/js/26.a40964a8.js"><link rel="prefetch" href="/assets/js/27.f1a91351.js"><link rel="prefetch" href="/assets/js/28.998de35a.js"><link rel="prefetch" href="/assets/js/29.bad79c17.js"><link rel="prefetch" href="/assets/js/3.64aa5436.js"><link rel="prefetch" href="/assets/js/30.341a8b04.js"><link rel="prefetch" href="/assets/js/31.aa115302.js"><link rel="prefetch" href="/assets/js/32.16ad8e51.js"><link rel="prefetch" href="/assets/js/33.6e4baef8.js"><link rel="prefetch" href="/assets/js/34.5bf638c5.js"><link rel="prefetch" href="/assets/js/35.96884e71.js"><link rel="prefetch" href="/assets/js/4.6ebf9fab.js"><link rel="prefetch" href="/assets/js/5.87def82c.js"><link rel="prefetch" href="/assets/js/6.8760c3fe.js"><link rel="prefetch" href="/assets/js/7.ce6961ce.js"><link rel="prefetch" href="/assets/js/8.638fa8dd.js"><link rel="prefetch" href="/assets/js/9.bbfb2b29.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9cd8b68b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.jpg" alt="yy3535" class="logo"> <span class="site-name can-hide">yy3535</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/frontend/" class="nav-link">前端</a></div><div class="nav-item"><a href="/backend/" class="nav-link">后端</a></div><div class="nav-item"><a href="/operation/" class="nav-link">运维</a></div><div class="nav-item"><a href="/todo/" class="nav-link">待整理</a></div><div class="nav-item"><a href="https://github.com/yy3535/yy3535" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/frontend/" class="nav-link">前端</a></div><div class="nav-item"><a href="/backend/" class="nav-link">后端</a></div><div class="nav-item"><a href="/operation/" class="nav-link">运维</a></div><div class="nav-item"><a href="/todo/" class="nav-link">待整理</a></div><div class="nav-item"><a href="https://github.com/yy3535/yy3535" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <!----> </div> <div class="page"> <div class="content"><h1 id="vue"><a href="#vue" aria-hidden="true" class="header-anchor">#</a> vue</h1> <p></p><div class="table-of-contents"><ul><li><a href="#start">start</a><ul><li><a href="#vm-new-vue-配置">vm=new Vue({})配置</a></li></ul></li><li><a href="#observer-响应式变化">observer(响应式变化)</a><ul><li><a href="#什么样的数据会更新">什么样的数据会更新</a></li><li><a href="#observer原理">observer原理</a></li></ul></li><li><a href="#vue实例上的方法">vue实例上的方法</a><ul><li><a href="#vm-el">vm.$el</a></li><li><a href="#vm-options">vm.$options</a></li><li><a href="#vm-nexttick">vm.$nextTick(()=&gt;{...})</a></li><li><a href="#vm-watch-info-xxx-function-newvalue-oldvalue">vm.$watch('info.xxx',function(newValue,oldValue){...})</a></li><li><a href="#vm-destroy-手动销毁组件">vm.$destroy 手动销毁组件</a></li><li><a href="#vm-on-click-change-绑定事件">vm.$on('click',change) 绑定事件</a></li></ul></li><li><a href="#template">template</a><ul><li><a href="#取值表达式">取值表达式{{}}</a></li></ul></li><li><a href="#指令">指令</a><ul><li><a href="#v-once-v-html">v-once,v-html</a></li><li><a href="#v-if-v-else">v-if v-else</a></li><li><a href="#v-for">v-for</a></li><li><a href="#v-model">v-model</a></li><li><a href="#绑定事件">@绑定事件</a></li><li><a href="#v-bind-或者">v-bind:或者:</a></li></ul></li><li><a href="#computed">computed</a><ul><li><a href="#watch实现computed">watch实现computed</a></li><li><a href="#computed实现双向绑定">computed实现双向绑定</a></li></ul></li><li><a href="#生命周期">生命周期</a><ul><li><a href="#beforecreate">beforeCreate</a></li><li><a href="#created">created</a></li><li><a href="#beforemount">beforeMount</a></li><li><a href="#mounted（重要）">mounted（重要）</a></li><li><a href="#beforeupdate">beforeUpdate</a></li><li><a href="#updated">updated</a></li><li><a href="#beforedestroy（重要）">beforeDestroy（重要）</a></li><li><a href="#destroyed">destroyed</a></li></ul></li><li><a href="#组件-component">组件(component)</a><ul><li><a href="#组件化开发的优点：">组件化开发的优点：</a></li><li><a href="#全局组件">全局组件</a></li><li><a href="#局部组件">局部组件</a></li><li><a href="#组件交互">组件交互</a></li><li><a href="#异步组件">异步组件</a></li><li><a href="#使用-vue文件开发两种方法">使用.vue文件开发两种方法</a></li><li><a href="#递归组件">递归组件</a></li></ul></li><li><a href="#vue-cli-3-0">vue-cli 3.0</a><ul><li><a href="#创建项目">创建项目</a></li><li><a href="#打包">打包</a></li><li><a href="#express">express</a></li><li><a href="#defer-async-preload-prefetch">defer &amp; async /preload &amp; prefetch</a></li><li><a href="#基于vue-cli编写组件-小球滚动组件">基于vue-cli编写组件---小球滚动组件</a></li></ul></li><li><a href="#vue-router-钩子的用法">vue-router 钩子的用法</a><ul><li><a href="#安装">安装</a></li><li><a href="#路由的两种方式">路由的两种方式</a></li><li><a href="#使用">使用</a></li><li><a href="#vuex-模块的">vuex 模块的</a></li><li><a href="#axios-获取数据">axios 获取数据</a></li><li><a href="#jwt-实现-权限-vuex-jwt-鉴权">jwt 实现 权限 vuex+jwt 鉴权</a></li><li><a href="#报错">报错</a></li><li><a href="#google工具">google工具</a></li></ul></li></ul></div><p></p> <h2 id="start"><a href="#start" aria-hidden="true" class="header-anchor">#</a> start</h2> <ul><li><p>渐进式
可按需使用</p></li> <li><p>逐一递增
vue+components+vue-router+vuex+vue-cli</p></li> <li><p>库和框架的区别</p> <p>库：调用库中的方法实现自己的功能</p> <p>框架：我们在指定的位置写好代码，框架帮我们调用</p></li> <li><p>mvc和mvvm区别</p> <p>mvc单向，model-view-controller，数据变化后需要通过controller手动改变视图</p> <p>mvvm双向，model-view-viewmodel，数据变化可以驱动视图，vm就是viewmodel</p></li> <li><p>声明式和命令式</p> <p>reduce不知道内部如何实现，是声明式</p> <p>for循环，命令计算机帮执行，叫做命令式</p></li></ul> <h3 id="vm-new-vue-配置"><a href="#vm-new-vue-配置" aria-hidden="true" class="header-anchor">#</a> vm=new Vue({})配置</h3> <div class="language- extra-class"><pre class="language-text"><code>let vm=new Vue({
    //范围 
    el:'#app',
    //替换范围中内容
    template:'&lt;h1&gt;hello world&lt;/h1&gt;',
    //存放数据,把数据代理给了vm。用之前需要先声明。
    data:{
      info:{xxx:'xxx'}
    }
}).$mount('#app')//与el相同作用，二选一
</code></pre></div><p><strong>注：</strong>
el换成.$mount('#app')是一样的。
单元测试时会用到。</p> <h2 id="observer-响应式变化"><a href="#observer-响应式变化" aria-hidden="true" class="header-anchor">#</a> observer(响应式变化)</h2> <h3 id="什么样的数据会更新"><a href="#什么样的数据会更新" aria-hidden="true" class="header-anchor">#</a> 什么样的数据会更新</h3> <ol><li><p>对象需要先声明存在，才能触发数据更新。</p></li> <li><p>数组需要改写，改写后length变化不能监听</p> <div class="language-let arr=['push','slice','shift','unshift'] extra-class"><pre class="language-text"><code> arr.forEach(method=&gt;{
   let oldPush=Array.prototype[method];
   Array.prototype[method]=function(value){
     console.log('数据更新了')
     oldPush.call(this,value)//别人身上的方法，想要使用到自己身上，就用call去调用
   }
 })
 obj.age.push(5)```
</code></pre></div></li> <li><p>值设置为对象才有效，需要修改某个值，可以使用vm.$set(vm.info,'address','zf');</p> <p>vm.info.address='world'//无效</p> <p>vm.info={address:'回龙观'}//有效，</p></li></ol> <h3 id="observer原理"><a href="#observer原理" aria-hidden="true" class="header-anchor">#</a> observer原理</h3> <div class="language- extra-class"><pre class="language-text"><code>let obj={
    name:'jw',
    age:{
    	age:18
    }
}
//vue数据劫持 Object.defineProperty
function observer(obj){
  if(typeof obj=='object'){
    for(let key in obj){
      defineReactive(obj,key,obj[key]);
    }
  }
}
function defineReactive(obj,key,value){
	observer(value);//判断 value是不是对象，如果是对象，会继续监控
  Object.defineProperty(obj,key,{
    get(){
      return value
    },
    set(val){
      observer(val);//如果设置的值是对象 需要在进行这个对象的监控
      console.log('数据更新了')
      value=val;
    }
  })
}
observer(obj)
obj.age.age='zf'
</code></pre></div><h2 id="vue实例上的方法"><a href="#vue实例上的方法" aria-hidden="true" class="header-anchor">#</a> vue实例上的方法</h2> <h3 id="vm-el"><a href="#vm-el" aria-hidden="true" class="header-anchor">#</a> vm.$el</h3> <p>当前挂载的元素</p> <h3 id="vm-options"><a href="#vm-options" aria-hidden="true" class="header-anchor">#</a> vm.$options</h3> <p>当前实例的参数</p> <h3 id="vm-nexttick"><a href="#vm-nexttick" aria-hidden="true" class="header-anchor">#</a> vm.$nextTick(()=&gt;{...})</h3> <p>视图更新后再执行
(vue数据变化后更新视图操作是异步执行的)</p> <h3 id="vm-watch-info-xxx-function-newvalue-oldvalue"><a href="#vm-watch-info-xxx-function-newvalue-oldvalue" aria-hidden="true" class="header-anchor">#</a> vm.$watch('info.xxx',function(newValue,oldValue){...})</h3> <p>数据变化后执行
(多次更新只会触发一次)</p> <h3 id="vm-destroy-手动销毁组件"><a href="#vm-destroy-手动销毁组件" aria-hidden="true" class="header-anchor">#</a> vm.$destroy 手动销毁组件</h3> <h3 id="vm-on-click-change-绑定事件"><a href="#vm-on-click-change-绑定事件" aria-hidden="true" class="header-anchor">#</a> vm.$on('click',change) 绑定事件</h3> <h2 id="template"><a href="#template" aria-hidden="true" class="header-anchor">#</a> template</h2> <h3 id="取值表达式"><a href="#取值表达式" aria-hidden="true" class="header-anchor">#</a> 取值表达式{{}}</h3> <p>作用：</p> <ul><li>运算</li> <li>取值</li> <li>三元</li></ul> <p><strong>注：</strong></p> <ul><li>其中的this都是指代vm实例，可省略</li> <li>取值时放对象，加空格即可 {
  &quot;name&quot;: 1
}</li></ul> <h2 id="指令"><a href="#指令" aria-hidden="true" class="header-anchor">#</a> 指令</h2> <h3 id="v-once-v-html"><a href="#v-once-v-html" aria-hidden="true" class="header-anchor">#</a> v-once,v-html</h3> <h4 id="v-once"><a href="#v-once" aria-hidden="true" class="header-anchor">#</a> v-once</h4> <p>只渲染一次，数据变化了也不更新视图</p> <h4 id="v-html"><a href="#v-html" aria-hidden="true" class="header-anchor">#</a> v-html</h4> <p>渲染成dom元素</p> <p><strong>注：</strong>
v-html使用innerHTML,所以不要将用户输入的内容展现出来，内容必须为可信任
&lt;img src=&quot;x&quot; onerror=&quot;alert()&quot; /&gt; 图片找不到会走onerror事件，就会弹出alert框</p> <h3 id="v-if-v-else"><a href="#v-if-v-else" aria-hidden="true" class="header-anchor">#</a> v-if v-else</h3> <ul><li>必须是连一块的</li> <li>可使用template无意义标签来框起来</li></ul> <p><strong>v-if和v-show的区别：</strong>
v-if控制dom有没有，v-show控制样式不显示，v-show不支持template</p> <h3 id="v-for"><a href="#v-for" aria-hidden="true" class="header-anchor">#</a> v-for</h3> <div class="language- extra-class"><pre class="language-text"><code>//循环数组
&lt;div v-for=&quot;(fruit,index) in fruits&quot; :key=&quot;index&quot;&gt;{{fruit}}{{index}}&lt;/div&gt;
//循环对象
&lt;div v-for=&quot;(value,key) in fruits&quot; :key=&quot;key&quot;&gt;{{value}}{{key}}&lt;/div&gt;
</code></pre></div><ul><li><p>循环谁就把它放在谁身上</p></li> <li><p>vue2.5以上要求必须使用key属性</p></li> <li><p>可使用template无意义标签来框起来</p></li></ul> <p><strong>注：</strong></p> <ol><li>key只能加在循环的元素上，不能加在template上，应该加在内部循环的元素上</li></ol> <pre><code>```
&lt;template v-for=&quot;i in 3&quot;&gt;
&lt;div :key=&quot;${i}_1&quot;&gt;&lt;/div&gt;
&lt;div :key=&quot;${i}_2&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
```
</code></pre> <ol start="2"><li>key也可以用来区分元素</li></ol> <pre><code>```
//修改flag值后不会立刻渲染，因为认为是同一个东西，加了key之后就会立刻重新渲染
&lt;div v-if=&quot;flag&quot;&gt;
	&lt;span&gt;珠峰&lt;/span&gt;
	&lt;input type=&quot;text&quot; key=&quot;1&quot;/&gt;
&lt;/div&gt;
&lt;div v-else&gt;
	&lt;span&gt;架构&lt;/span&gt;
	&lt;input type=&quot;text&quot; key=&quot;2&quot;/&gt;
&lt;/div&gt;
```
</code></pre> <ol start="3"><li>尽量不要用index来作为key，因为index再数据顺序变化后会消耗性能，如果有唯一标识，尽量用唯一标识</li></ol> <h3 id="v-model"><a href="#v-model" aria-hidden="true" class="header-anchor">#</a> v-model</h3> <h4 id="input"><a href="#input" aria-hidden="true" class="header-anchor">#</a> input</h4> <div class="language- extra-class"><pre class="language-text"><code>&lt;input type='text' :value=&quot;msg&quot; @input=&quot;e=&gt;{msg=e.target.value}&quot;/&gt;
等价于  &lt;!-- v-model 是 @input + :value 的一个语法糖--&gt;
&lt;input type='text' v-model=&quot;msg&quot;/&gt;
</code></pre></div><h4 id="select-radio和checkbox"><a href="#select-radio和checkbox" aria-hidden="true" class="header-anchor">#</a> select,radio和checkbox</h4> <div class="language- extra-class"><pre class="language-text"><code>//select
data:{
	selectValue:'',
	list:['{value:'菜单1',id:1}','{value:'菜单2',id:2}','{value:'菜单3',id:3}']
}
&lt;select v-model=&quot;selectValue&quot;&gt;
	&lt;option value=&quot;0&quot; disabled&gt;请选择&lt;/option&gt;
	&lt;option v-for=&quot;item in list&quot; :key=&quot;item.id&quot; :value=&quot;item.id&quot;&gt;{{item.value}}&lt;/option&gt;
&lt;/select&gt;
//multiple，太丑一般不用

//radio
//根据v-model来分组
data:{
	radioValue:'男'
}
&lt;input type='radio' v-model=&quot;radioValue&quot; value=&quot;男&quot;/&gt;
&lt;input type='radio' v-model=&quot;radioValue&quot; value=&quot;女&quot;/&gt;
&lt;input type='radio' v-model=&quot;radioValue&quot; value=&quot;其他&quot;/&gt;

//checkbox
//只要是多个就是数组
data:{
	checkValue:true,
 checkValues:[]
}
不给value，值就是true/false，给了value，就是数组
&lt;!--true/false--&gt;
&lt;input type='checkbox' v-model=&quot;checkValue&quot;/&gt;
&lt;!--多选--&gt;
&lt;input type='checkbox' v-model=&quot;checkValues&quot; value=&quot;游泳&quot;/&gt;
&lt;input type='checkbox' v-model=&quot;checkValues&quot; value=&quot;健身&quot;/&gt;
&lt;input type='checkbox' v-model=&quot;checkValues&quot; value=&quot;看书&quot;/&gt;
{{checkValues}}
</code></pre></div><h4 id="修饰符（可以连续修饰）"><a href="#修饰符（可以连续修饰）" aria-hidden="true" class="header-anchor">#</a> 修饰符（可以连续修饰）</h4> <div class="language- extra-class"><pre class="language-text"><code>  &lt;input type=&quot;text&quot; v-model.number=&quot;val&quot;&gt;{{typeof val}}//只能数字
  &lt;input type=&quot;text&quot; v-model.trim=&quot;val&quot;&gt;{{typeof val}}//清除空格
</code></pre></div><h3 id="绑定事件"><a href="#绑定事件" aria-hidden="true" class="header-anchor">#</a> @绑定事件</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;input type='text' @input=&quot;fn&quot;/&gt;

methods:{
  fn(){...}
}
</code></pre></div><ul><li>绑定方法，写在method中，this指向vm实例，data中不能放方法，因为this指向window</li> <li>methods中不要写成fn:()=&gt;{}，否则this就指向window了</li> <li>方法传参：
<ol><li>需要传参就加括号写参数，无参数则不加括号</li> <li>默认有e事件参数，有传参时，保留$event参数作为事件参数</li></ol></li></ul> <h4 id="修饰符-可以连续修饰"><a href="#修饰符-可以连续修饰" aria-hidden="true" class="header-anchor">#</a> 修饰符(可以连续修饰)</h4> <p>@keyup.按键名称/按键unicode码//只有按了该按键才响应</p> <p>常用：.ctrl .esc .enter</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;input type=&quot;text&quot; @keyup.enter=&quot;fn&quot;&gt;
&lt;input type=&quot;text&quot; @keyup.esc=&quot;fn&quot;&gt;
</code></pre></div><p>vue配置一个键盘code别名,需要按fn+f1</p> <div class="language- extra-class"><pre class="language-text"><code>Vue.config.keyCodes={
  'f1':112
}
</code></pre></div><h3 id="v-bind-或者"><a href="#v-bind-或者" aria-hidden="true" class="header-anchor">#</a> v-bind:或者:</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;input type='text' :value=&quot;msg&quot;/&gt;
</code></pre></div><ul><li>绑定属性</li></ul> <blockquote><p>动态绑定样式
class</p></blockquote> <ol><li>等于对象</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;div class=&quot;abc&quot; :class=&quot;{b:true}&quot;&gt;你好&lt;/div&gt;
</code></pre></div><ol start="2"><li>等于数组</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;div class=&quot;abc&quot; :class=&quot;['a','b',c]&quot;&gt;你好&lt;/div&gt;//c为data中定义的
</code></pre></div><p>style
等于对象或者数组</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div style='color:red' :style=&quot;{background:'blue'}&quot;&gt;
&lt;div style='color:red' :style=&quot;[{background:'red',color:'blue'}]&quot;&gt;
</code></pre></div><h2 id="computed"><a href="#computed" aria-hidden="true" class="header-anchor">#</a> computed</h2> <ul><li>methods getFullName()放取值表达式中会造成性能问题，每次其他数据更新都会重新执行这个方法</li> <li>computed也是通过Object.defineProperty来实现的，只有依赖的数据更新时才会执行（有缓存）</li></ul> <div class="language- extra-class"><pre class="language-text"><code>computed:{
  fullName(){
    return this.firstName+this.lastName;
  }
}
</code></pre></div><h3 id="watch实现computed"><a href="#watch实现computed" aria-hidden="true" class="header-anchor">#</a> watch实现computed</h3> <div class="language- extra-class"><pre class="language-text"><code>data:{
  firstName:'珠',
  lastName:'峰',
  fullName:'',
},
methods:{
  getFullName(){
    this.fullName=this.firstName+this.lastName;
  }
},
watch:{//相当于vm.$watch('firstname',()=&gt;{})
  //普通写法，需要mount来执行
  firstName(newValue){
    this.getFullName();
  },
  //其他写法
  firstName:{
    handler(newValue){
      this.getFullName();
    },
    //立即执行
    immediate:true
  }
  lastName(){
    this.getFullName();
  }
}
</code></pre></div><blockquote><p>computed和method的区别？
computed只有绑定的数据变了才会执行，method做绑定时所有数据变了都会执行</p></blockquote> <blockquote><p>computed和watch的区别？</p></blockquote> <ul><li>watch支持异步，可以实现一些简单的功能，一般会先考虑使用computed，不能再用watch</li></ul> <h3 id="computed实现双向绑定"><a href="#computed实现双向绑定" aria-hidden="true" class="header-anchor">#</a> computed实现双向绑定</h3> <div class="language- extra-class"><pre class="language-text"><code>全选：&lt;input type=&quot;checkbox&quot; v-model=&quot;checkAll&quot;&gt;
&lt;input type=&quot;checkbox&quot; v-for=&quot;(item,key) in checks&quot; v-model=&quot;item.value&quot; :key=&quot;key&quot;&gt;
data:{
  checks:[{value:true},{value:false},{value:true},]
},
computed:{
  checkAll:{
    get(){
      return this.checks.every(check=&gt;check.value)
    },
    set(kvalue){
      this.checks.forEach(check=&gt;check.value=value);
    }
  }
}
</code></pre></div><h2 id="生命周期"><a href="#生命周期" aria-hidden="true" class="header-anchor">#</a> 生命周期</h2> <p>初始化自己的生命周期，并且绑定自己的事件</p> <ul><li>this.$data
vm.data</li></ul> <h3 id="beforecreate"><a href="#beforecreate" aria-hidden="true" class="header-anchor">#</a> beforeCreate</h3> <p>实例尚未创建完成
初始化注入，和响应事件</p> <div class="language- extra-class"><pre class="language-text"><code>data:{
  a:1
},
beforeCreate(){
  console.log(this)//undefined
  console.log(this.$data)//undefined
}

</code></pre></div><h3 id="created"><a href="#created" aria-hidden="true" class="header-anchor">#</a> created</h3> <p>可以获取数据和调用方法</p> <div class="language- extra-class"><pre class="language-text"><code>create(){
  console.log(this)//存在
  console.log(this.$data)//{a:1}
}
</code></pre></div><h3 id="beforemount"><a href="#beforemount" aria-hidden="true" class="header-anchor">#</a> beforeMount</h3> <p>渲染前，第一次调用渲染函数执行，可以拿到data,method等</p> <h3 id="mounted（重要）"><a href="#mounted（重要）" aria-hidden="true" class="header-anchor">#</a> mounted（重要）</h3> <p>渲染后，可获取真实dom，一般ajax请求放在这儿。</p> <div class="language- extra-class"><pre class="language-text"><code>mounted(){
  console.log(this.$el.innerHTML);
}
</code></pre></div><h3 id="beforeupdate"><a href="#beforeupdate" aria-hidden="true" class="header-anchor">#</a> beforeUpdate</h3> <p>更新前</p> <div class="language- extra-class"><pre class="language-text"><code>beforeUpdate(){
  console.log(this.$el.innerHTML);
}
</code></pre></div><h3 id="updated"><a href="#updated" aria-hidden="true" class="header-anchor">#</a> updated</h3> <p>一般不要操作数据，否则可能会死循环
更新后</p> <div class="language- extra-class"><pre class="language-text"><code>updated(){
  console.log(this.$el.innerHTML);
}
</code></pre></div><h3 id="beforedestroy（重要）"><a href="#beforedestroy（重要）" aria-hidden="true" class="header-anchor">#</a> beforeDestroy（重要）</h3> <p>销毁前（当前实例还可以用），一般会放销毁定时器等解绑操作</p> <div class="language- extra-class"><pre class="language-text"><code>beforeDestroy(){
  console.log(this.$el.innerHTML);
}
</code></pre></div><h3 id="destroyed"><a href="#destroyed" aria-hidden="true" class="header-anchor">#</a> destroyed</h3> <p>销毁后（实例上的方法，监听，事件绑定都被移除）</p> <div class="language- extra-class"><pre class="language-text"><code>destroyed(){
  console.log(this.$el.innerHTML);
}
</code></pre></div><blockquote><p>什么情况会走destroy?</p></blockquote> <ul><li><p>路由切换
一个组件切换到另一个组件，上一个组件要销毁</p></li> <li><p>vm.$destroy()
手动销毁</p></li></ul> <p><img src="/img/lifecycle.png" alt="vue生命周期"></p> <h2 id="组件-component"><a href="#组件-component" aria-hidden="true" class="header-anchor">#</a> 组件(component)</h2> <h3 id="组件化开发的优点："><a href="#组件化开发的优点：" aria-hidden="true" class="header-anchor">#</a> 组件化开发的优点：</h3> <ul><li><p>一个页面分为几个组件开发，方便协作，方便维护，可复用</p></li> <li><p>要采用闭合标签</p></li> <li><p>为了每个组件的数据，互不影响，data采用函数</p></li></ul> <h3 id="全局组件"><a href="#全局组件" aria-hidden="true" class="header-anchor">#</a> 全局组件</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id='app'&gt;
  &lt;my-button&gt;&lt;/my-button&gt;
  &lt;my-button&gt;&lt;/my-button&gt;
  &lt;my-button&gt;&lt;/my-button&gt;
&lt;/div&gt;
&lt;script&gt;
  //组件实际上就是个对象
  Vue.component('my-button',{
    template:`&lt;button&gt;{{msg}}&lt;/button&gt;`,
    data(){
      return {
        msg:'点我啊'
      }
    }
  })
  //根实例，也是一个组件
  let vm=new Vue({
    el:'#app',
  })
&lt;/script&gt;
</code></pre></div><h3 id="局部组件"><a href="#局部组件" aria-hidden="true" class="header-anchor">#</a> 局部组件</h3> <p>声明在某个组件之内</p> <ul><li>子组件在父组件的模板中使用</li> <li>组件名定义时写大驼峰，使用时用<code>-</code>连接，因为html标签不能有大写字母</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//父组件
&lt;div id='app'&gt;
  &lt;my-button&gt;&lt;/my-button&gt;
  &lt;my-button&gt;&lt;/my-button&gt;
  &lt;my-button&gt;&lt;/my-button&gt;
&lt;/div&gt;
let vm = new Vue({
  el:&quot;#app&quot;,
  //子组件
  components:{
    'MyButton':{
      data(){
        return {msg:'点我啊'}
      },
      template:`&lt;button&gt;{{}}&lt;/button&gt;`
    }
  }
})
</code></pre></div><h3 id="组件交互"><a href="#组件交互" aria-hidden="true" class="header-anchor">#</a> 组件交互</h3> <p>prop</p> <h4 id="prop传值"><a href="#prop传值" aria-hidden="true" class="header-anchor">#</a> prop传值</h4> <ul><li>简单传值</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Vue.component('blog-post', {
  props: ['title'],
  template: '&lt;h3&gt;{{ title }}&lt;/h3&gt;'
})

&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;
&lt;blog-post title=&quot;Blogging with Vue&quot;&gt;&lt;/blog-post&gt;
&lt;blog-post title=&quot;Why Vue is so fun&quot;&gt;&lt;/blog-post&gt;

My journey with Vue
Blogging with Vue
Why Vue is so fun
</code></pre></div><ul><li>传一个数组</li></ul> <div class="language- extra-class"><pre class="language-text"><code>new Vue({
  el: '#blog-post-demo',
  data: {
    posts: [
      { id: 1, title: 'My journey with Vue' },
      { id: 2, title: 'Blogging with Vue' },
      { id: 3, title: 'Why Vue is so fun' }
    ]
  }
})

&lt;blog-post
  v-for=&quot;post in posts&quot;
  v-bind:key=&quot;post.id&quot;
  v-bind:title=&quot;post.title&quot;
&gt;&lt;/blog-post&gt;
</code></pre></div><h4 id="this-attrs"><a href="#this-attrs" aria-hidden="true" class="header-anchor">#</a> this.$attrs</h4> <p>没有使用的属性</p> <h4 id="prop大小写"><a href="#prop大小写" aria-hidden="true" class="header-anchor">#</a> prop大小写</h4> <p>当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名</p> <div class="language- extra-class"><pre class="language-text"><code>Vue.component('blog-post', {
  // 在 JavaScript 中是 camelCase 的
  props: ['postTitle'],
  template: '&lt;h3&gt;{{ postTitle }}&lt;/h3&gt;'
})
&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;
&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt;
</code></pre></div><h4 id="prop类型"><a href="#prop类型" aria-hidden="true" class="header-anchor">#</a> prop类型</h4> <p>每个 prop 都有指定的值类型,可以以对象形式列出 prop，这些属性的名称和值分别是 prop 各自的名称和类型</p> <div class="language- extra-class"><pre class="language-text"><code>props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // or any other constructor
}
</code></pre></div><h4 id="传递静态或动态-prop"><a href="#传递静态或动态-prop" aria-hidden="true" class="header-anchor">#</a> 传递静态或动态 Prop</h4> <ul><li>静态prop</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;
</code></pre></div><ul><li>动态prop</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 动态赋予一个变量的值 --&gt;
&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;

&lt;!-- 动态赋予一个复杂表达式的值 --&gt;
&lt;blog-post
  v-bind:title=&quot;post.title + ' by ' + post.author.name&quot;
&gt;&lt;/blog-post&gt;
</code></pre></div><h5 id="传入一个对象的所有属性"><a href="#传入一个对象的所有属性" aria-hidden="true" class="header-anchor">#</a> 传入一个对象的所有属性</h5> <p>如果你想要将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 v-bind</p> <div class="language- extra-class"><pre class="language-text"><code>post: {
  id: 1,
  title: 'My Journey with Vue'
}
</code></pre></div><p>下面的模板：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt;
</code></pre></div><p>等价于：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;blog-post
  v-bind:id=&quot;post.id&quot;
  v-bind:title=&quot;post.title&quot;
&gt;&lt;/blog-post&gt;
</code></pre></div><h5 id="禁用特性继承"><a href="#禁用特性继承" aria-hidden="true" class="header-anchor">#</a> 禁用特性继承</h5> <div class="language- extra-class"><pre class="language-text"><code>Vue.component('my-component', {
  inheritAttrs: false,//没有用到的属性，不会显示在dom结构上了
  //
  template:`&lt;div&gt;my-button &lt;my v-bind=&quot;$attrs&quot;&gt;&lt;/my&gt;&lt;/div&gt;`,
  components:{
    'my':{
      props:['a','b'],
      template:`&lt;span&gt;{{a}} {{b}}&lt;/span&gt;`
    }
  }
})
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let vm=new Vue({
  el:'#app',
  data:{
    content:'点我啊'
  },
  components:{
    'MyButton':{
      mounted(){
        //对没有使用的属性 把他保留在this.$attrs中
        console.log(this.$attrs)
      },
      inheritAttrs:false,//没有用到的数据，就不会显示在dom结构上了
      template:`&lt;div&gt;my-button &lt;my v-bind=&quot;$attrs&quot;&gt;&lt;/my&gt;&lt;/div&gt;`,
      components:{
        'my':{
          props:['a','b'],
          template:`&lt;span&gt;{{a}}{{b}}&lt;/span&gt;`
        }
      }
    }
  }
})
</code></pre></div><h5 id="props"><a href="#props" aria-hidden="true" class="header-anchor">#</a> props</h5> <p>属性父级传子组件</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;my-button :a=&quot;1&quot; b=&quot;2&quot; :arr=&quot;[1,2,3]&quot;&gt;&lt;/my-button&gt;
componets:{
  'MyButton':{
    props:{
      msg:{
        //类型，校验只会出错误，但不影响页面渲染
        type:String,
        //默认值
        default:'点我啊'
      },
      a:{
        type:Number
      },
      b:{
        type:String,
        //验证
        validator(value){
          return value&gt;3
        }
      },
      arr:{
        type:Array,
        //属性校验中，如果是数组/对象，需要将默认值返回
        default:()=&gt;([1,2])//箭头函数后面是括号表示[1,2]是个返回值
      }
    },
    template:`&lt;button&gt;{{msg}}{{a}}{{b}}&lt;/button&gt;`
  }
}

</code></pre></div><h5 id="子组件触发父级的方法"><a href="#子组件触发父级的方法" aria-hidden="true" class="header-anchor">#</a> 子组件触发父级的方法</h5> <p><strong>子组件触发父级的方法，给子组件最外层元素绑定。</strong>
@click.native</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;app&quot;&gt;
  &lt;my-button @click.native=&quot;change&quot;&gt;&lt;/my-button&gt;
&lt;/div&gt;
&lt;script&gt;
  let vm=new Vue({
    el:'#app',
    data:{
      content:'点我啊'
    },
    methods:{
      change(){
        alert(1);
      }
    }
    components:{
      'MyButton':{
        template:`&lt;button&gt;点我啊&lt;/button&gt;`
      }
    }
  })
&lt;/script&gt;
</code></pre></div><p><strong>组件的某个子元素触发父级方法（调用自己属性上的父级的方法），有三种方法。</strong></p> <ul><li>this.$attrs //获取当前组件所有的属性</li> <li>this.$listeners //获取当前组件所有的绑定事件</li></ul> <ol><li>@click=&quot;$listeners.click()&quot;</li> <li>@click=&quot;this.$emit('click')&quot;</li> <li>v-on=&quot;$listeners&quot;</li></ol> <div class="language- extra-class"><pre class="language-text"><code>  &lt;div id=&quot;app&quot;&gt;
    &lt;!--相当于 this.on('click',change)--&gt;
    &lt;my-button @click=&quot;change&quot; @mouseup=&quot;change&quot;&gt;&lt;/my-button&gt;
  &lt;/div&gt;
  template:`&lt;div&gt;
    //第一种
    &lt;button @click=“$listeners.click()”&gt;点我啊&lt;/button&gt;
    //第二种
    &lt;button @click=&quot;$emit('click')&quot;&gt;&lt;/button&gt;
    //第三种,所有事件全绑上去
    &lt;button v-on=&quot;$listeners&quot;&gt;&lt;/button&gt;
  &lt;/div&gt;`

</code></pre></div><blockquote><p>v-bind=$attrs 绑定所有的属性
v-on=$listeners 绑定所有的方法</p></blockquote> <h5 id="总结：props-emit-attrs-listeners-parent-children"><a href="#总结：props-emit-attrs-listeners-parent-children" aria-hidden="true" class="header-anchor">#</a> 总结：props emit | $attrs $listeners | $parent $children</h5> <h5 id="parent-children"><a href="#parent-children" aria-hidden="true" class="header-anchor">#</a> $parent $children</h5> <ul><li><p>$parent
获取父组件的实例</p></li> <li><p>$children
获取所有的子组件</p></li> <li><p>slot插槽
name：</p></li></ul> <ol><li>default</li> <li>自定义:hello
v-slot:/#/</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;template v-slot:hello&gt;
  ...
&lt;/template&gt;
或者
&lt;template #:hello&gt;
  ...
&lt;/template&gt;
或者
&lt;div class=&quot;wrap&quot;&gt;
  &lt;slot&gt;&lt;/slot&gt;
&lt;/div&gt;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//手风琴效果组件
&lt;div id=&quot;app&quot;&gt;
  &lt;collapse&gt;
    &lt;collapse-item title=&quot;react&quot;&gt;内容1&lt;/collapse-item&gt;
    &lt;collapse-item title=&quot;vue&quot;&gt;内容2&lt;/collapse-item&gt;
    &lt;collapse-item title=&quot;node&quot;&gt;内容3&lt;/collapse-item&gt;
  &lt;/collapse&gt;
&lt;/div&gt;
&lt;script&gt;
  Vue.component('Collapse',{
    methods:{
      cut(childId){
        this.$children.forEach(child=&gt;{
          if(child._uid!==childId){
            child.show=false
          }
        })
      }
    },
    template:`&lt;div class=&quot;wrap&quot;&gt;
      &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;`
  });
  Vue.component('CollapseItem',{
    props:['title'],
    data(){
      return {
        show:false
      }
      
    },
    methods:{
      change(){
        this.$parent.cut(this._uid);
        this.show=!this.show;
      }
    }
    template:`&lt;div&gt;
      &lt;div class=&quot;title&quot; @click=&quot;change&quot;&gt;{{title}}&lt;/div&gt;
      &lt;div v-show=&quot;show&quot;&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/div&gt;
    &lt;/div&gt;`
  })
  let vm=new Vue({
    el:'#app'
  })
&lt;/script&gt;
</code></pre></div><h5 id="provide"><a href="#provide" aria-hidden="true" class="header-anchor">#</a> provide</h5> <p>在根组件上提供属性，所有的子组件都可以获取
可实现组件传值</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;app&quot;&gt;
  &lt;my&gt;&lt;/my&gt;
&lt;/div&gt;
Vue.component('my',{
  inject:['a'],
  template:&quot;&lt;div&gt;{{a}}&lt;/div&gt;&quot;
})
let vm=new Vue({
  el:'#app',
  provide:{
    a:1
  },
  mounted(){
    console.log(this._uid)
  }
})
</code></pre></div><h5 id="总结：组件间通信"><a href="#总结：组件间通信" aria-hidden="true" class="header-anchor">#</a> 总结：组件间通信</h5> <ol><li>prop和$emit
父组件向子组件传递通过prop,子组件向父组件传递通过$emit</li> <li>$attrs和$listeners
Vue2.4开始提供$attrs和$listeners传递值</li> <li>$parent,$children</li> <li>$refs
获取实例</li> <li>provider和inject
父组件通过provider提供变量，子组件通过inject来注入变量</li> <li>eventBus
平级组件数据传递，可使用中央事件总线方式</li> <li>vuex状态管理</li></ol> <h5 id="refs"><a href="#refs" aria-hidden="true" class="header-anchor">#</a> $refs</h5> <p>获取所有引用</p> <ul><li>ref名不能重复，重复会覆盖。但如果遇到循环，就会成数组形式</li> <li>子组件给一个ref,父组件调用this.$refs.com.show传值，父组件调用子组件的方法</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;app&quot;&gt;
    &lt;template v-for=&quot;i in 3&quot;&gt;
        &lt;div ref=&quot;my&quot;&gt;我的dom元素&lt;/div&gt;
    &lt;/template&gt;
    &lt;my-component ref=&quot;com&quot;&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    let vm=new Vue({
        el:'#app',
        mounted(){
            console.log(this.$refs.my)
            console.log(this.$refs.com.show)
        },
        components:{
            'myComponent':{
                methods:{
                    show(){
                        alert(1)
                    }
                },
                template:`&lt;div&gt;my-component&lt;/div&gt;`
            }
        }
    })
&lt;/script&gt;
</code></pre></div><h5 id="自定义指令-directive"><a href="#自定义指令-directive" aria-hidden="true" class="header-anchor">#</a> 自定义指令(directive)</h5> <p>Vue自带指令：v-model v-html v-text {{}} v-cloak v-if/v-else v-show v-pre 有十几种
指令有全局和局部</p> <ul><li><p>自定义指令
默认函数形式
Vue.directive('xxx',function(el,bindings,vnode){
...<br>
});
相当于bind和update
Vue.directive('xxx',function(el,bindings,vnode){
//只当数据更新时指令生效
update(el,bindings,vnode){
...
},
//只当用户绑定时指令生效
bind(el,bindings,vnode){
...
}
});</p></li> <li><p>自定义只取长度为三的字符串的指令且双向绑定</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; v-split.3.xxx=&quot;msg&quot;&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.directive('split',{
        bind(el,bindings,vnode){
            let ctx=vnode.context;//当前指令所在的组件
            let [,len]=bindings.rawName.split('.');
            el.addEventListener('input',(e)=&gt;{
                let val=e.target.value.slice(0,len);
                ctx[bingdings.expression]=val;
                el.value=val;
            })
            //赋予默认值
            el.value=ctx[bingdings.expression].value.slice(0,3);
        }
    });
    let vm=new Vue({
        el:'#app',
        data:{
            msg:'a'
        }
    })
&lt;/script&gt;
</code></pre></div><ul><li>inserted
dom渲染完成后执行，相当于bind加了nextTick</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Vue.directive('focus',{
    bind(el){
        //dom渲染出来后
        Vue.nextTick(()=&gt;{
            //绑定事件
            el.focus()
        })
    }
    inserted(el){
        el.focus()
    }
})
</code></pre></div><ul><li>指令和过滤器函数中的this是window，所以不能用this</li></ul> <h5 id="过滤器-filter"><a href="#过滤器-filter" aria-hidden="true" class="header-anchor">#</a> 过滤器(filter)</h5> <ul><li>只改变数据的展示形式 并不会改变原数据，可用computed替代</li> <li>分为全局和局部过滤器</li> <li>指令和过滤器函数中的this是window，所以不能用this</li></ul> <p>Vue.filter('xxx',function(value,len){
...
})</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;app&quot;&gt;
    {{name | capitalize(2)}}
&lt;/div&gt;
&lt;script&gt;
    Vue.filter('capitalize',function(value,len){
        return value.slice(0,len).toUpperCase()+value.slice(len);
    })
    let vm=new Vue({
        el:'#app',
        data:{
            flag:false,
            name:'zfjq'
        },
        filter(value,len){
            ...
        }
    })
&lt;/script&gt;
</code></pre></div><h3 id="异步组件"><a href="#异步组件" aria-hidden="true" class="header-anchor">#</a> 异步组件</h3> <p>组件在异步加载完成后再显示出来，
一般需要配合webpack的懒加载来使用</p> <div class="language- extra-class"><pre class="language-text"><code>Vue.component('my-component',function(resolve){
    setTimeout(()=&gt;{
        resolve({
            template:'&lt;h1&gt;hello&lt;/h1&gt;'
        })
    },1000)
})
</code></pre></div><h3 id="使用-vue文件开发两种方法"><a href="#使用-vue文件开发两种方法" aria-hidden="true" class="header-anchor">#</a> 使用.vue文件开发两种方法</h3> <ul><li><p>安装vue-cli脚手架
npm install @vue/cli -g</p></li> <li><p>安装service-global
npm install -g @vue/cli-service-global</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>vue serve App.vue
//http://localhost:8080/直接访问组件页面
</code></pre></div><h3 id="递归组件"><a href="#递归组件" aria-hidden="true" class="header-anchor">#</a> 递归组件</h3> <p>.vue文件组件</p> <ul><li><p>组件大写可辨认<code>&lt;MenuItem&gt;</code></p></li> <li><p>使用</p> <ol><li>定义组件</li> <li>引用组件</li> <li>注册组件</li></ol></li> <li><p>用于树结构，菜单等</p></li> <li><p>组件中使用<code>name:'ReSub'</code>给自己命名,使用<code>&lt;ReSub&gt;&lt;/ReSub&gt;</code>可以调用自己，实现递归组件。</p></li> <li><p>把共同的循环的部分抽离成组件，然后在组件中调用自己。</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>//App.vue
&lt;template&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;Menu&gt;
            &lt;template v-for=&quot;menu in menuList&quot;&gt;
                &lt;MenuItem 
                    :key=&quot;menu.title&quot; 
                    v-if=&quot;!menu.children&quot;
                &gt;
                    {menu.title}
                &lt;/MenuItem&gt;
                &lt;!-- 把重复的部分抽离出去 --&gt;
                &lt;ReSubMenu :key=&quot;menu.title&quot; v-else :data=&quot;menu.children&quot;&gt;&lt;/ReSubMenu&gt;
            &lt;/template&gt;
        &lt;/Menu&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
//.vue可省略
import Menu from './Menu';
import MenuItem from './MenuItem';
import SubMenu from './SubMenu';
import ReSubMenu from './ReSubMenu';
export default {
    data(){
        return {
            menuList:[
                {
                    title:'菜单1',
                    children:[
                        {
                            title:'菜单1-1',
                            children:[
                                {title:'菜单1-1-1'},
                                {title:'菜单1-1-2'},
                                {title:'菜单1-1-3'},
                            ]
                        },
                        {title:'菜单1-1'},
                        {title:'菜单1-1'},
                    ]
                },
                {
                    title:'菜单2'
                },
                {
                    title:'菜单3'
                }
            ]
        }
    },
    components:{
        Menu,MenuItem,SubMenu,ReSubMenu
    }
}
&lt;/script&gt;
&lt;style&gt;
#app{
    color:red;
}
&lt;/style&gt;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//Menu.vue

</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//MenuItem.vue
&lt;template&gt;
    &lt;div&gt;
        &lt;li&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/li&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    data(){
        return {msg:'hello'}
    }
}
&lt;/script&gt;
&lt;style&gt;
&lt;/style&gt;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//SubMenu.vue
&lt;template&gt;
    &lt;div&gt;
        &lt;div class=&quot;title&quot; @click=&quot;change&quot;&gt;
            &lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div v-show=&quot;flag&quot; class=&quot;sub&quot;&gt;
            &lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    data(){
        return {flag:false}
    },
    methods:{
        change(){
            this.flag=!this.flag;
        }
    }
}
&lt;/script&gt;
&lt;style&gt;
    .sub{
        padding-left:20px;
    }
&lt;/style&gt;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//ReSubMenu.vue
&lt;template&gt;
    &lt;SubMenu&gt;
        &lt;template #title&gt;
            {{data.title}}
        &lt;/template&gt;
        &lt;template v-for=&quot;child in data.children&quot;&gt;
            &lt;MenuItem :key=&quot;child.title&quot; v-if=&quot;!child.children&quot;&gt;{{child.title}}&lt;/MenuItem&gt;
            &lt;ReSub :key=&quot;child.title&quot; v-else :data=&quot;child&quot;&gt;&lt;/ReSub&gt;
        &lt;/template&gt;
    &lt;/SubMenu&gt;
&lt;/template&gt;
&lt;script&gt;
import SubMenu from './SubMenu'
import MenuItem from './MenuItem'
export default {
    name:'ReSub',//可以使用递归组件
    props:{
        data:{
            type:Object,
            default:()=&gt;({})
        },
    },
    components:{
        SubMenu,MenuItem
    }
}
&lt;/script&gt;
&lt;style&gt;

&lt;/style&gt;
</code></pre></div><h2 id="vue-cli-3-0"><a href="#vue-cli-3-0" aria-hidden="true" class="header-anchor">#</a> vue-cli 3.0</h2> <h3 id="创建项目"><a href="#创建项目" aria-hidden="true" class="header-anchor">#</a> 创建项目</h3> <ol><li><p>vue create xxx/vue ui(可视化)
vue create vue-router-apply</p></li> <li><p>选手动
default(babel,eslint)//默认配置(包括babel和eslint)
Manually select features//手动配置</p></li> <li><p>选配置
babel,CSS</p></li> <li><p>配置放独立文件</p></li> <li><p>进入项目文件夹
cd vue-router-apply
yarn serve</p></li> <li><p>可新建vue.config.js来重置webpack配置
//vue.config.js基于node,node不支持import语法</p></li></ol> <div class="language- extra-class"><pre class="language-text"><code>//webpack配置
let path=require('path');
module.exports={
    //baseURL
    //默认环境变量 NODE_ENV production devlopment
    //打包后的结果带域名，开发中不带
    publicPath:process.env.NODE_ENV==='production'?'http://www.zhufeng.cn':'/',
    //assets打包成一个独立文件assets
    assetsDir:'asserts',
    //打包目录
    outputDir:'./my-dist',
    //使用模板方式 一般不使用 render改成template
    runtimeCompiler:true,
    //打包不再使用sourcemap
    productionSourceMap:false, 
    //修改webpack内部配置（获取webpack配置并给它添加自己的逻辑）
    chainWebpack:config=&gt;{
        //给目录src配置了别名'+'，路径可以用+代替src
        config.resolve.alias.set('+',path.resolve(__dirname,'src'))
    },
    //新增其他webpack配置
    configureWebpack:{
        plugins:[],
        module:{}
    },
    //配置开发服务时使用
    devServer:{
        //代理解决跨域：8080 -&gt; 自己的8080服务器 =&gt; 3000，服务访问服务是不受限的。
        //开发环境使用，生产环境前端+后台=&gt;同一个服务器，就没有跨域问题了
        //一般情况下如果不是没有后端程序员不需要用代理，直接请求头复制一下。
        proxy:{
            //http://localhost:8080/getUser帮我代理到http://localhost:3000/getUser
            '/getUser':{
                target:&quot;http://localhost:3000&quot;
            }
        }
    },
    //第三方插件配置
    //可以使用三种方法配置插件：1. vue ui 安装插件 2. vue add style-resources-loader，相当于npm install @vue/cli-style-resource-loader 3. 在这儿配置
    pluginOptions:{
        //会给每个组件都引入这样一个样式文件
        'style-resources-loader':{
            preProcessor:'less',
            patterns:[
                path.resolve(__dirname,'src/assets/common.less')
            ]
        }
    }
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//HelloWorld.vue
&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
    123
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import axios from 'axios'
export default {
  name: 'HelloWorld',
  props: {
    msg: String
  },
  mounted(){
    //没写默认是`http://localhost:8080/getUser`
    axios.get('getUser').then(data=&gt;{
      console.log(data)
    })
  }
}
&lt;/script&gt;
</code></pre></div><ul><li><p>scope
限制当前css只在当前组件上使用</p></li> <li><p>lang
使用语言设置
less/</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;style scoped lang=&quot;less&quot;&gt;
@import '../assets/common.less';
.hello{
  color:@color
}
&lt;/style&gt;
</code></pre></div><ul><li>less文件</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//common.less
@color:red;
</code></pre></div><h3 id="打包"><a href="#打包" aria-hidden="true" class="header-anchor">#</a> 打包</h3> <p>npm run build，出现dist目录</p> <h3 id="express"><a href="#express" aria-hidden="true" class="header-anchor">#</a> express</h3> <p>vue 启动服务通过express，所以内置了express.</p> <div class="language- extra-class"><pre class="language-text"><code>//server.js
let express=require('express');

let app=express();

app.get('/getUser',(req,res)=&gt;{
    res.json({name:'zfpx'});
})

app.listen(3000)
</code></pre></div><h3 id="defer-async-preload-prefetch"><a href="#defer-async-preload-prefetch" aria-hidden="true" class="header-anchor">#</a> defer &amp; async /preload &amp; prefetch</h3> <h3 id="基于vue-cli编写组件-小球滚动组件"><a href="#基于vue-cli编写组件-小球滚动组件" aria-hidden="true" class="header-anchor">#</a> 基于vue-cli编写组件---小球滚动组件</h3> <ul><li>组件的id问题，<code>_uid</code>用于标识组件的每个实例</li> <li>属性(校验 ,计算属性)</li> <li>双向通信(props+emit / v-model / .sync),三种一种比一种简单,其中v-model用的最多</li> <li>数据绑定($refs 拿到子组件的方法，来调用组件中的方法)</li> <li>注意：子组件中的this.observer.define拦截，而this.timer不需要。直接赋值就行了。</li> <li>h5的requestAnimationFrame、cancelAnimationFrame代替setTimeout</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//App.vue
&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    
    &lt;!-- 第三种   :value.sync=&quot;xxx&quot;=:xxx + this.$emit('update:xxx')--&gt;
    &lt;!-- pos5是pos4得语法糖 --&gt;
    &lt;ScrollBall color=&quot;red&quot; :target=&quot;300&quot; :value.sync=&quot;pos5&quot; ref=&quot;ball5&quot;&gt;红球&lt;/ScrollBall&gt;
    &lt;ScrollBall color=&quot;red&quot; :value=&quot;pos4&quot; :target=&quot;300&quot; @update:value=&quot;value=&gt;pos4=value&quot;&gt;红球&lt;/ScrollBall&gt;
    &lt;!-- 第二种   v-model=:value+input --&gt;
    &lt;!-- pos3是pos1得语法糖 --&gt;
    &lt;ScrollBall color=&quot;red&quot; v-model=&quot;pos3&quot; :target=&quot;300&quot;&gt;红球&lt;/ScrollBall&gt;
    &lt;ScrollBall color=&quot;red&quot; :value=&quot;pos1&quot; :target=&quot;300&quot; @input='input'&gt;红球&lt;/ScrollBall&gt;
    &lt;!-- 第一种   props+emit --&gt;
    &lt;ScrollBall color=&quot;blue&quot; :value=&quot;pos2&quot; :target=&quot;500&quot;&gt;蓝球&lt;/ScrollBall&gt;
    &lt;button @click=&quot;getPosition&quot;&gt;获取球1的位置&lt;/button&gt;
    &lt;button @click=&quot;stop&quot;&gt;停&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import ScrollBall from './components/ScrollBall'
export default {
  name: 'app',
  data(){
    return {
      pos1:50,
      pos2:100,
      pos3:60,
      pos4:200,
      pos5:190,
    }
  },
  components:{
    ScrollBall,
  },
  methods:{
    getPosition(){

    },
    input(value){
      this.pos1=value;
    },
    stop(){
      this.$refs.ball5.stop()
    }
  }
}
&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//ScrollBall.vue
&lt;template&gt;
    &lt;div class=&quot;ball&quot; :style=&quot;style&quot; :id=&quot;ballId&quot;&gt;
        &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    name:'scroll-ball',
    props:{
        color:{
            type:String,
            default:'white'
        },
        value:{
            type:Number,
            default:0
        },
        target:{
            type:Number,
            default:300
        }
    },
    methods:{
        stop(){
            cancelAnimationFrame(this.timer)
        }
    },
    mounted(){
        //单向数据流 子组件通知父亲，当前自己的位置，父亲更新位置，再传递给子组件
        let ball=document.getElementById(this.ballId)
        let fn=()=&gt;{
            let left=this.value;
            if(left&gt;=this.target){
                return cancelAnimationFrame(this.timer)
            }
            this.$emit('input',left+2)
            this.$emit('update:value',left+2)
            ball.style.transform=`translate(${this.value}px)`;
            this.timer=requestAnimationFrame(fn)
        }
        //requestAnimationFrame根据浏览器刷新频率来设置，性能比setTimeout高一点
        this.timer=requestAnimationFrame(fn)
    },
    computed:{
        ballId(){
            //通过uid来区分组件的实例
            return `ball_`+this._uid
        },
        style(){
            return {background:this.color}
        }
    }
}
&lt;/script&gt;


&lt;style scoped lang=&quot;less&quot;&gt;
    .ball{
        width:100px;
        height: 100px;
        border-radius: 50%;
        text-align: center;
        line-height: 100px;
        border: 1px solid red;
    }

&lt;/style&gt;
</code></pre></div><h2 id="vue-router-钩子的用法"><a href="#vue-router-钩子的用法" aria-hidden="true" class="header-anchor">#</a> vue-router 钩子的用法</h2> <h3 id="安装"><a href="#安装" aria-hidden="true" class="header-anchor">#</a> 安装</h3> <p>yarn add vue-router</p> <h3 id="路由的两种方式"><a href="#路由的两种方式" aria-hidden="true" class="header-anchor">#</a> 路由的两种方式</h3> <blockquote><h1 id><a href="#" aria-hidden="true" class="header-anchor">#</a></h1></blockquote> <p>url加#xxx</p> <blockquote><p>history(h5api)
history.pushState({},null,'/a')
问题：刷新时浏览器会找不到路径</p></blockquote> <h3 id="使用"><a href="#使用" aria-hidden="true" class="header-anchor">#</a> 使用</h3> <h4 id="路由配置文件"><a href="#路由配置文件" aria-hidden="true" class="header-anchor">#</a> 路由配置文件</h4> <ul><li>第三方插件 引入后要使用Vue.use() =&gt; install</li> <li>install注册了两个全局组件：
<code>router-link</code> 链接
<code>router-view</code> 路由视图</li> <li>install定义了两个变量：
<code>$router</code>,<code>this.$router</code>,包含方法
<code>$route</code>,<code>this.$route</code>,包含属性</li> <li>导出路由配置</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//router/index.js
import Vue from 'vue';
import VueRouter from 'vue-router';

Vue.use(VueRouter);

//默认导出
export default new VueRouter({
    //路由形式(默认hash，history)
    mode:'hash / history',
    //路由映射表(建议单独一个routes.js文件导出routes)
    routes,
})

</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//routes.js
import Home from '_v/Home';
import Name from '_v/Name.vue';
import Version from '_v/Version.vue';

export default [
    //首页显示
    {
        path:'/',
        //重定向去首页(需要用path)
        redirect:{path:'/home'}
    },
    {
        path:'/home',
        name:'home',
        //一个路由多个组件
        components:{
            default:Home,
            name:Name,
            version:Version
        }
    },
    {
        path:'/login',
        name:'login',
        //组件懒加载(现在是页面进入所有组件都加载。希望点击时才加载组件,使用`懒加载`,但可能会导致白屏问题)
        component:()=&gt;import('_v/Login.vue')
    },
    {
        path:'/profile',
        name:'profile',
        component:()=&gt;import('_v/Profile.vue')
    },
    {
        path:'/user',
        name:'user',
        component:()=&gt;import('_v/User.vue'),
        //子路由(//path'/'代表根目录，所以'/add'表示根目录下的add,'add'表示'/user/add')
        children:[
            //设置默认显示（使用时必须用路径跳转，不能使用name）
            {
                path:'',
                component:()=&gt;import('_v/UserAdd')
            },
            {
                path:'add',
                name:'userAdd',
                component:()=&gt;import('_v/UserAdd')
            },
            {
                path:'list',
                name:'userList',
                component:()=&gt;import('_v/UserList')
            }
        ]
    },
    //路由都匹配不到的情况
    {
        path:'*',
        component:()=&gt;import('_v/404')
    }
]
</code></pre></div><ul><li>导入文件目录太繁琐应定义别名</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//vue.config.js
config.resolve.alias.set('_',path.resolve(__dirname,'src/components'))

config.resolve.alias.set('_v',path.resolve(__dirname,'src/views'))
</code></pre></div><ul><li></li></ul> <h4 id="在vue实例中引用路由"><a href="#在vue实例中引用路由" aria-hidden="true" class="header-anchor">#</a> 在Vue实例中引用路由</h4> <div class="language- extra-class"><pre class="language-text"><code>//main.js
import Vue from 'vue'
import App from './App.vue'
import router from './router'
Vue.config.productionTip = false

new Vue({
  router,//在实例中引用路由
  render: h =&gt; h(App),
}).$mount('#app')

</code></pre></div><h4 id="在vue实例模板中显示路由视图"><a href="#在vue实例模板中显示路由视图" aria-hidden="true" class="header-anchor">#</a> 在Vue实例模板中显示路由视图</h4> <ul><li>//一个路由一个组件</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//App.vue
&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: 'app',
  data(){
    return {}
  }
}
&lt;/script&gt;
&lt;style&gt;
&lt;/style&gt;

</code></pre></div><ul><li>//一个路由多个组件</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;div class=&quot;container&quot;&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
  &lt;router-view name=&quot;name&quot;&gt;&lt;/router-view&gt;
  &lt;router-view name=&quot;version&quot;&gt;&lt;/router-view&gt;
&lt;/div&gt;
</code></pre></div><h4 id="点击路由跳转-声明式路由跳转"><a href="#点击路由跳转-声明式路由跳转" aria-hidden="true" class="header-anchor">#</a> 点击路由跳转(声明式路由跳转)</h4> <p>router-link</p> <ul><li>to属性
to='home'
to='/home'
:to='{path:'/home'}'
:to='{name:'home'}'
to='/user/detail?id=1'</li> <li>tag属性
链接无下划线
tag='span'</li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;router-link to='/home'&gt;首页&lt;/router-link&gt;
&lt;router-link to='login'&gt;登录&lt;/router-link&gt;
&lt;router-link :to=&quot;{name:'profile'}&quot;&gt;个人中心&lt;/router-link&gt;
&lt;router-link :to=&quot;{path:'/user'}&quot;&gt;用户&lt;/router-link&gt;

//传参1(问号传参)
&lt;router-link to=&quot;/user/detail?id=1&quot;&gt;用户详情&lt;/router-link&gt;
{{this.$route.query.id}}

//传参2(路径传参)
{
  path:'detail/:id',
  name:'userDetail,
  component:()=&gt;import('_v/UserDetail.vue)
}
&lt;router-link to=&quot;/user/detail/1&quot;&gt;用户详情&lt;/router-link&gt;
{{this.$route.params.id}}

</code></pre></div><blockquote><p>bootstrap
yarn add bootstrap3</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>//main.js中全局引用
import 'bootstrap/dist/css/bootstrap.css'
</code></pre></div><h4 id="编程式路由跳转"><a href="#编程式路由跳转" aria-hidden="true" class="header-anchor">#</a> 编程式路由跳转</h4> <p>this.$router.push(path)</p> <div class="language- extra-class"><pre class="language-text"><code>this.$router.push('/user/list')
</code></pre></div><h4 id="路由钩子函数"><a href="#路由钩子函数" aria-hidden="true" class="header-anchor">#</a> 路由钩子函数</h4> <p>例如：离开一个组件前即一个组件销毁前提示是否离开。next表示是否往下走</p> <ol><li>组件中的路由钩子</li></ol> <ul><li>beforeRouteLeave</li> <li>beforeRouterEnter</li> <li>beforeRouterUpdate</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//login.vue
export default {
  //离开钩子(离开组建，组件销毁时)
  beforeRouteLeave (to, from, next) {
    if(this.username){
        let confirm=window.confirm('你需要切换吗')
        if(confirm){
            next()
        }
    }else{
        next()
    }
  }
  //进入之前钩子
  beforeRouterEnter(to, from, next){
    //此方法中不能拿到this
    if(from.name==='userAdd'){
        console.log('是这里过来的')
    }
    next(vm=&gt;{
        //组件渲染完成后会回调，可以在这里拿到当前实例
        console.og(vm);
    })
  },
  //当前路由更新钩子(相当于监控$route,一般与mount配合使用，当属性变化时，并没有重新加载组件，但会触发这个)
  beforeRouterUpdate(to, from, next){
      next();
  },
  watch:{
      $route(){
          alert(1)
      }
  }
}


</code></pre></div><ol start="2"><li>路由配置中的路由钩子(在组件之前触发)</li></ol> <ul><li>beforeEnter</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//routes.js
{
    path:'/profile',
    name:'profile',
    component:()=&gt;import('_v/Profile.vue'),
    beforeEnter:(to,from,next){
      next()
    }
},
</code></pre></div><ol><li>全局路由钩子(在组件，路由配置之前，对所有路由有效)</li></ol> <ul><li>router.beforeEach</li> <li>router.beforeResolve</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//main.js
import Vue from 'vue'
import App from './App.vue'
import router from './router'

//进入当前路由之前触发
router.beforeEach((to,from,next)=&gt;{
  next();
})
//当前路由解析后触发
router.beforeResolve((to,from,next)=&gt;{
  next();
})
//当前路由进入完毕后触发
router.afterEach(()=&gt;{

})
new Vue({
  router,
  render: h =&gt; h(App),
}).$mount('#app')
</code></pre></div><h5 id="路由钩子总结"><a href="#路由钩子总结" aria-hidden="true" class="header-anchor">#</a> 路由钩子总结</h5> <p>当组件切换时：</p> <ol><li>离开钩子(组件beforeRouterLeave)</li> <li>进入新页面之前(全局beforeEach--&gt;路由配置beforeEnter--&gt;组件beforeRouterEnter)</li> <li>路由解析完成(全局beforeResolve)</li> <li>页面进入完成(全局afterEach)</li> <li>属性变化，但没有重新加载组件(组件beforeRouteUpdate)</li> <li>组件渲染完成(组件beforeRouterEnter回调)</li></ol> <h5 id="【官网】完整的导航解析流程（背）"><a href="#【官网】完整的导航解析流程（背）" aria-hidden="true" class="header-anchor">#</a> 【官网】完整的导航解析流程（背）</h5> <ol><li>导航被触发。</li> <li>在失活的组件里调用离开守卫。</li> <li>调用全局的 beforeEach 守卫。</li> <li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li> <li>在路由配置里调用 beforeEnter。</li> <li>解析异步路由组件。</li> <li>在被激活的组件里调用 beforeRouteEnter。</li> <li>调用全局的 beforeResolve 守卫 (2.5+)。</li> <li>导航被确认。</li> <li>调用全局的 afterEach 钩子。</li> <li>触发 DOM 更新。</li> <li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li></ol> <h3 id="vuex-模块的"><a href="#vuex-模块的" aria-hidden="true" class="header-anchor">#</a> vuex 模块的</h3> <h3 id="axios-获取数据"><a href="#axios-获取数据" aria-hidden="true" class="header-anchor">#</a> axios 获取数据</h3> <h3 id="jwt-实现-权限-vuex-jwt-鉴权"><a href="#jwt-实现-权限-vuex-jwt-鉴权" aria-hidden="true" class="header-anchor">#</a> jwt 实现 权限 vuex+jwt 鉴权</h3> <h3 id="报错"><a href="#报错" aria-hidden="true" class="header-anchor">#</a> 报错</h3> <ul><li>No ESLint configuration found
npm install eslint --save-dev
./node_modules/.bin/eslint --init 初始化配置文件.eslintrc.js</li></ul> <h3 id="google工具"><a href="#google工具" aria-hidden="true" class="header-anchor">#</a> google工具</h3> <ul><li>vuetools<div class="language- extra-class"><pre class="language-text"><code>&lt;Root&gt;根实例
  &lt;App&gt;&lt;/App&gt;App实例
&lt;Root&gt;
</code></pre></div></li></ul></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">5/14/2019, 9:03:34 AM</span></div></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.14dbe886.js" defer></script><script src="/assets/js/24.f0f70b8c.js" defer></script>
  </body>
</html>
