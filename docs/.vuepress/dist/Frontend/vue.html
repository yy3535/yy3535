<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue | yy3535</title>
    <meta name="description" content="yy3535的笔记">
    <link rel="icon" href="/img/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.9cd8b68b.css" as="style"><link rel="preload" href="/assets/js/app.1dc331ee.js" as="script"><link rel="preload" href="/assets/js/23.50f603d8.js" as="script"><link rel="prefetch" href="/assets/js/10.a344c9d6.js"><link rel="prefetch" href="/assets/js/11.2bb37a81.js"><link rel="prefetch" href="/assets/js/12.16003787.js"><link rel="prefetch" href="/assets/js/13.b84385e3.js"><link rel="prefetch" href="/assets/js/14.2e88bfe4.js"><link rel="prefetch" href="/assets/js/15.7c86f69b.js"><link rel="prefetch" href="/assets/js/16.8bee7c9a.js"><link rel="prefetch" href="/assets/js/17.618caf53.js"><link rel="prefetch" href="/assets/js/18.990b9a63.js"><link rel="prefetch" href="/assets/js/19.2f20fd09.js"><link rel="prefetch" href="/assets/js/2.066c3c73.js"><link rel="prefetch" href="/assets/js/20.77aa05bc.js"><link rel="prefetch" href="/assets/js/21.b2e8086f.js"><link rel="prefetch" href="/assets/js/22.c4a94626.js"><link rel="prefetch" href="/assets/js/24.fa485a05.js"><link rel="prefetch" href="/assets/js/25.dba8eabc.js"><link rel="prefetch" href="/assets/js/26.46962900.js"><link rel="prefetch" href="/assets/js/27.b7265a22.js"><link rel="prefetch" href="/assets/js/28.0a1f3971.js"><link rel="prefetch" href="/assets/js/29.4be129ef.js"><link rel="prefetch" href="/assets/js/3.0150abfa.js"><link rel="prefetch" href="/assets/js/30.0c5e46e5.js"><link rel="prefetch" href="/assets/js/31.b9532dfa.js"><link rel="prefetch" href="/assets/js/32.d6f7c0e4.js"><link rel="prefetch" href="/assets/js/4.e8b3ad54.js"><link rel="prefetch" href="/assets/js/5.f461a1d5.js"><link rel="prefetch" href="/assets/js/6.d464a650.js"><link rel="prefetch" href="/assets/js/7.f0fd3517.js"><link rel="prefetch" href="/assets/js/8.b79b245e.js"><link rel="prefetch" href="/assets/js/9.88c61673.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9cd8b68b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.jpg" alt="yy3535" class="logo"> <span class="site-name can-hide">yy3535</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/frontend/" class="nav-link router-link-active">前端</a></div><div class="nav-item"><a href="/backend/" class="nav-link">后端</a></div><div class="nav-item"><a href="/operation/" class="nav-link">运维</a></div><div class="nav-item"><a href="/todo/" class="nav-link">待整理</a></div><div class="nav-item"><a href="https://github.com/yy3535/yy3535" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/frontend/" class="nav-link router-link-active">前端</a></div><div class="nav-item"><a href="/backend/" class="nav-link">后端</a></div><div class="nav-item"><a href="/operation/" class="nav-link">运维</a></div><div class="nav-item"><a href="/todo/" class="nav-link">待整理</a></div><div class="nav-item"><a href="https://github.com/yy3535/yy3535" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading"><span>js</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/frontend/js/jsbasic/" class="sidebar-link">01-JS基础知识</a></li><li><a href="/frontend/js/jswebapi/" class="sidebar-link">02-JS-WEB-API</a></li><li><a href="/frontend/js/devenv/" class="sidebar-link">03-开发环境</a></li><li><a href="/frontend/js/runenv/" class="sidebar-link">04-运行环境</a></li><li><a href="/frontend/js/es6/" class="sidebar-link">ES6</a></li><li><a href="/frontend/js/designpatterns/" class="sidebar-link">前端设计模式</a></li><li><a href="/frontend/js/jsbasic/zepto/" class="sidebar-link">zepto源码解读</a></li><li><a href="/frontend/js/jsbasic/shenrubibao/" class="sidebar-link">深入理解javascript原型链和闭包</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>css</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/frontend/css.html" class="sidebar-link">css</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading open"><span>vue</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/frontend/vue.html" class="active sidebar-link">vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/vue.html#start" class="sidebar-link">start</a></li><li class="sidebar-sub-header"><a href="/frontend/vue.html#observer-响应式变化" class="sidebar-link">observer(响应式变化)</a></li><li class="sidebar-sub-header"><a href="/frontend/vue.html#vue实例上的方法" class="sidebar-link">vue实例上的方法</a></li><li class="sidebar-sub-header"><a href="/frontend/vue.html#template" class="sidebar-link">template</a></li><li class="sidebar-sub-header"><a href="/frontend/vue.html#指令" class="sidebar-link">指令</a></li><li class="sidebar-sub-header"><a href="/frontend/vue.html#computed" class="sidebar-link">computed</a></li><li class="sidebar-sub-header"><a href="/frontend/vue.html#生命周期" class="sidebar-link">生命周期</a></li><li class="sidebar-sub-header"><a href="/frontend/vue.html#组件-component" class="sidebar-link">组件(component)</a></li></ul></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>webpack</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/frontend/webpack.html" class="sidebar-link">webpack</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>小工具</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/frontend/vuepress.html" class="sidebar-link">vuepress</a></li><li><a href="/frontend/markdown.html" class="sidebar-link">markdown 语法</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="vue"><a href="#vue" aria-hidden="true" class="header-anchor">#</a> vue</h1> <p></p><div class="table-of-contents"><ul><li><a href="#start">start</a><ul><li><a href="#vm-new-vue-配置">vm=new Vue({})配置</a></li></ul></li><li><a href="#observer-响应式变化">observer(响应式变化)</a><ul><li><a href="#什么样的数据会更新">什么样的数据会更新</a></li><li><a href="#observer原理">observer原理</a></li></ul></li><li><a href="#vue实例上的方法">vue实例上的方法</a><ul><li><a href="#vm-el">vm.$el</a></li><li><a href="#vm-options">vm.$options</a></li><li><a href="#vm-nexttick">vm.$nextTick(()=&gt;{...})</a></li><li><a href="#vm-watch-info-xxx-function-newvalue-oldvalue">vm.$watch('info.xxx',function(newValue,oldValue){...})</a></li><li><a href="#vm-destroy-手动销毁组件">vm.$destroy 手动销毁组件</a></li></ul></li><li><a href="#template">template</a><ul><li><a href="#取值表达式">取值表达式{{}}</a></li></ul></li><li><a href="#指令">指令</a><ul><li><a href="#v-once-v-html">v-once,v-html</a></li><li><a href="#v-if-v-else">v-if v-else</a></li><li><a href="#v-for">v-for</a></li><li><a href="#v-model">v-model</a></li><li><a href="#绑定事件">@绑定事件</a></li><li><a href="#v-bind-或者">v-bind:或者:</a></li></ul></li><li><a href="#computed">computed</a><ul><li><a href="#watch实现computed">watch实现computed</a></li><li><a href="#computed实现双向绑定">computed实现双向绑定</a></li></ul></li><li><a href="#生命周期">生命周期</a><ul><li><a href="#beforecreate">beforeCreate</a></li><li><a href="#created">created</a></li><li><a href="#beforemount">beforeMount</a></li><li><a href="#mounted（重要）">mounted（重要）</a></li><li><a href="#beforeupdate">beforeUpdate</a></li><li><a href="#updated">updated</a></li><li><a href="#beforedestroy（重要）">beforeDestroy（重要）</a></li><li><a href="#destroyed">destroyed</a></li></ul></li><li><a href="#组件-component">组件(component)</a><ul><li><a href="#组件化开发的优点：">组件化开发的优点：</a></li><li><a href="#全局组件">全局组件</a></li><li><a href="#局部组件">局部组件</a></li><li><a href="#组件交互">组件交互</a></li></ul></li></ul></div><p></p> <h2 id="start"><a href="#start" aria-hidden="true" class="header-anchor">#</a> start</h2> <ul><li><p>渐进式
可按需使用</p></li> <li><p>逐一递增
vue+components+vue-router+vuex+vue-cli</p></li> <li><p>库和框架的区别</p> <p>库：调用库中的方法实现自己的功能</p> <p>框架：我们在指定的位置写好代码，框架帮我们调用</p></li> <li><p>mvc和mvvm区别</p> <p>mvc单向，model-view-controller，数据变化后需要通过controller手动改变视图</p> <p>mvvm双向，model-view-viewmodel，数据变化可以驱动视图，vm就是viewmodel</p></li> <li><p>声明式和命令式</p> <p>reduce不知道内部如何实现，是声明式</p> <p>for循环，命令计算机帮执行，叫做命令式</p></li></ul> <h3 id="vm-new-vue-配置"><a href="#vm-new-vue-配置" aria-hidden="true" class="header-anchor">#</a> vm=new Vue({})配置</h3> <div class="language- extra-class"><pre class="language-text"><code>let vm=new Vue({
    //范围 
    el:'#app',
    //替换范围中内容
    template:'&lt;h1&gt;hello world&lt;/h1&gt;',
    //存放数据,把数据代理给了vm。用之前需要先声明。
    data:{
      info:{xxx:'xxx'}
    }
}).$mount('#app')//与el相同作用，二选一
</code></pre></div><p><strong>注：</strong>
el换成.$mount('#app')是一样的。
单元测试时会用到。</p> <h2 id="observer-响应式变化"><a href="#observer-响应式变化" aria-hidden="true" class="header-anchor">#</a> observer(响应式变化)</h2> <h3 id="什么样的数据会更新"><a href="#什么样的数据会更新" aria-hidden="true" class="header-anchor">#</a> 什么样的数据会更新</h3> <ol><li><p>对象需要先声明存在，才能触发数据更新。</p></li> <li><p>数组需要改写，改写后length变化不能监听</p> <div class="language-let arr=['push','slice','shift','unshift'] extra-class"><pre class="language-text"><code> arr.forEach(method=&gt;{
   let oldPush=Array.prototype[method];
   Array.prototype[method]=function(value){
     console.log('数据更新了')
     oldPush.call(this,value)//别人身上的方法，想要使用到自己身上，就用call去调用
   }
 })
 obj.age.push(5)```
</code></pre></div></li> <li><p>值设置为对象才有效，需要修改某个值，可以使用vm.$set(vm.info,'address','zf');</p> <p>vm.info.address='world'//无效</p> <p>vm.info={address:'回龙观'}//有效，</p></li></ol> <h3 id="observer原理"><a href="#observer原理" aria-hidden="true" class="header-anchor">#</a> observer原理</h3> <div class="language- extra-class"><pre class="language-text"><code>let obj={
    name:'jw',
    age:{
    	age:18
    }
}
//vue数据劫持 Object.defineProperty
function observer(obj){
  if(typeof obj=='object'){
    for(let key in obj){
      defineReactive(obj,key,obj[key]);
    }
  }
}
function defineReactive(obj,key,value){
	observer(value);//判断 value是不是对象，如果是对象，会继续监控
  Object.defineProperty(obj,key,{
    get(){
      return value
    },
    set(val){
      observer(val);//如果设置的值是对象 需要在进行这个对象的监控
      console.log('数据更新了')
      value=val;
    }
  })
}
observer(obj)
obj.age.age='zf'
</code></pre></div><h2 id="vue实例上的方法"><a href="#vue实例上的方法" aria-hidden="true" class="header-anchor">#</a> vue实例上的方法</h2> <h3 id="vm-el"><a href="#vm-el" aria-hidden="true" class="header-anchor">#</a> vm.$el</h3> <p>当前挂载的元素</p> <h3 id="vm-options"><a href="#vm-options" aria-hidden="true" class="header-anchor">#</a> vm.$options</h3> <p>当前实例的参数</p> <h3 id="vm-nexttick"><a href="#vm-nexttick" aria-hidden="true" class="header-anchor">#</a> vm.$nextTick(()=&gt;{...})</h3> <p>视图更新后再执行
(vue数据变化后更新视图操作是异步执行的)</p> <h3 id="vm-watch-info-xxx-function-newvalue-oldvalue"><a href="#vm-watch-info-xxx-function-newvalue-oldvalue" aria-hidden="true" class="header-anchor">#</a> vm.$watch('info.xxx',function(newValue,oldValue){...})</h3> <p>数据变化后执行
(多次更新只会触发一次)</p> <h3 id="vm-destroy-手动销毁组件"><a href="#vm-destroy-手动销毁组件" aria-hidden="true" class="header-anchor">#</a> vm.$destroy 手动销毁组件</h3> <h2 id="template"><a href="#template" aria-hidden="true" class="header-anchor">#</a> template</h2> <h3 id="取值表达式"><a href="#取值表达式" aria-hidden="true" class="header-anchor">#</a> 取值表达式{{}}</h3> <p>作用：</p> <ul><li>运算</li> <li>取值</li> <li>三元</li></ul> <p><strong>注：</strong></p> <ul><li>其中的this都是指代vm实例，可省略</li> <li>取值时放对象，加空格即可 {
  &quot;name&quot;: 1
}</li></ul> <h2 id="指令"><a href="#指令" aria-hidden="true" class="header-anchor">#</a> 指令</h2> <h3 id="v-once-v-html"><a href="#v-once-v-html" aria-hidden="true" class="header-anchor">#</a> v-once,v-html</h3> <h4 id="v-once"><a href="#v-once" aria-hidden="true" class="header-anchor">#</a> v-once</h4> <p>只渲染一次，数据变化了也不更新视图</p> <h4 id="v-html"><a href="#v-html" aria-hidden="true" class="header-anchor">#</a> v-html</h4> <p>渲染成dom元素</p> <p><strong>注：</strong>
v-html使用innerHTML,所以不要将用户输入的内容展现出来，内容必须为可信任
&lt;img src=&quot;x&quot; onerror=&quot;alert()&quot; /&gt; 图片找不到会走onerror事件，就会弹出alert框</p> <h3 id="v-if-v-else"><a href="#v-if-v-else" aria-hidden="true" class="header-anchor">#</a> v-if v-else</h3> <ul><li>必须是连一块的</li> <li>可使用template无意义标签来框起来</li></ul> <p><strong>v-if和v-show的区别：</strong>
v-if控制dom有没有，v-show控制样式不显示，v-show不支持template</p> <h3 id="v-for"><a href="#v-for" aria-hidden="true" class="header-anchor">#</a> v-for</h3> <div class="language- extra-class"><pre class="language-text"><code>//循环数组
&lt;div v-for=&quot;(fruit,index) in fruits&quot; :key=&quot;index&quot;&gt;{{fruit}}{{index}}&lt;/div&gt;
//循环对象
&lt;div v-for=&quot;(value,key) in fruits&quot; :key=&quot;key&quot;&gt;{{value}}{{key}}&lt;/div&gt;
</code></pre></div><ul><li><p>循环谁就把它放在谁身上</p></li> <li><p>vue2.5以上要求必须使用key属性</p></li> <li><p>可使用template无意义标签来框起来</p></li></ul> <p><strong>注：</strong></p> <ol><li>key只能加在循环的元素上，不能加在template上，应该加在内部循环的元素上</li></ol> <pre><code>```
&lt;template v-for=&quot;i in 3&quot;&gt;
&lt;div :key=&quot;${i}_1&quot;&gt;&lt;/div&gt;
&lt;div :key=&quot;${i}_2&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
```
</code></pre> <ol start="2"><li>key也可以用来区分元素</li></ol> <pre><code>```
//修改flag值后不会立刻渲染，因为认为是同一个东西，加了key之后就会立刻重新渲染
&lt;div v-if=&quot;flag&quot;&gt;
	&lt;span&gt;珠峰&lt;/span&gt;
	&lt;input type=&quot;text&quot; key=&quot;1&quot;/&gt;
&lt;/div&gt;
&lt;div v-else&gt;
	&lt;span&gt;架构&lt;/span&gt;
	&lt;input type=&quot;text&quot; key=&quot;2&quot;/&gt;
&lt;/div&gt;
```
</code></pre> <ol start="3"><li>尽量不要用index来作为key，因为index再数据顺序变化后会消耗性能，如果有唯一标识，尽量用唯一标识</li></ol> <h3 id="v-model"><a href="#v-model" aria-hidden="true" class="header-anchor">#</a> v-model</h3> <h4 id="input"><a href="#input" aria-hidden="true" class="header-anchor">#</a> input</h4> <div class="language- extra-class"><pre class="language-text"><code>&lt;input type='text' :value=&quot;msg&quot; @input=&quot;e=&gt;{msg=e.target.value}&quot;/&gt;
等价于  &lt;!-- v-model 是 @input + :value 的一个语法糖--&gt;
&lt;input type='text' v-model=&quot;msg&quot;/&gt;
</code></pre></div><h4 id="select-radio和checkbox"><a href="#select-radio和checkbox" aria-hidden="true" class="header-anchor">#</a> select,radio和checkbox</h4> <div class="language- extra-class"><pre class="language-text"><code>//select
data:{
	selectValue:'',
	list:['{value:'菜单1',id:1}','{value:'菜单2',id:2}','{value:'菜单3',id:3}']
}
&lt;select v-model=&quot;selectValue&quot;&gt;
	&lt;option value=&quot;0&quot; disabled&gt;请选择&lt;/option&gt;
	&lt;option v-for=&quot;item in list&quot; :key=&quot;item.id&quot; :value=&quot;item.id&quot;&gt;{{item.value}}&lt;/option&gt;
&lt;/select&gt;
//multiple，太丑一般不用

//radio
//根据v-model来分组
data:{
	radioValue:'男'
}
&lt;input type='radio' v-model=&quot;radioValue&quot; value=&quot;男&quot;/&gt;
&lt;input type='radio' v-model=&quot;radioValue&quot; value=&quot;女&quot;/&gt;
&lt;input type='radio' v-model=&quot;radioValue&quot; value=&quot;其他&quot;/&gt;

//checkbox
//只要是多个就是数组
data:{
	checkValue:true,
 checkValues:[]
}
不给value，值就是true/false，给了value，就是数组
&lt;!--true/false--&gt;
&lt;input type='checkbox' v-model=&quot;checkValue&quot;/&gt;
&lt;!--多选--&gt;
&lt;input type='checkbox' v-model=&quot;checkValues&quot; value=&quot;游泳&quot;/&gt;
&lt;input type='checkbox' v-model=&quot;checkValues&quot; value=&quot;健身&quot;/&gt;
&lt;input type='checkbox' v-model=&quot;checkValues&quot; value=&quot;看书&quot;/&gt;
{{checkValues}}
</code></pre></div><h4 id="修饰符（可以连续修饰）"><a href="#修饰符（可以连续修饰）" aria-hidden="true" class="header-anchor">#</a> 修饰符（可以连续修饰）</h4> <div class="language- extra-class"><pre class="language-text"><code>  &lt;input type=&quot;text&quot; v-model.number=&quot;val&quot;&gt;{{typeof val}}//只能数字
  &lt;input type=&quot;text&quot; v-model.trim=&quot;val&quot;&gt;{{typeof val}}//清除空格
</code></pre></div><h3 id="绑定事件"><a href="#绑定事件" aria-hidden="true" class="header-anchor">#</a> @绑定事件</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;input type='text' @input=&quot;fn&quot;/&gt;

methods:{
  fn(){...}
}
</code></pre></div><ul><li>绑定方法，写在method中，this指向vm实例，data中不能放方法，因为this指向window</li> <li>methods中不要写成fn:()=&gt;{}，否则this就指向window了</li> <li>方法传参：
<ol><li>需要传参就加括号写参数，无参数则不加括号</li> <li>默认有e事件参数，有传参时，保留$event参数作为事件参数</li></ol></li></ul> <h4 id="修饰符-可以连续修饰"><a href="#修饰符-可以连续修饰" aria-hidden="true" class="header-anchor">#</a> 修饰符(可以连续修饰)</h4> <p>@keyup.按键名称/按键unicode码//只有按了该按键才响应</p> <p>常用：.ctrl .esc .enter</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;input type=&quot;text&quot; @keyup.enter=&quot;fn&quot;&gt;
&lt;input type=&quot;text&quot; @keyup.esc=&quot;fn&quot;&gt;
</code></pre></div><p>vue配置一个键盘code别名,需要按fn+f1</p> <div class="language- extra-class"><pre class="language-text"><code>Vue.config.keyCodes={
  'f1':112
}
</code></pre></div><h3 id="v-bind-或者"><a href="#v-bind-或者" aria-hidden="true" class="header-anchor">#</a> v-bind:或者:</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;input type='text' :value=&quot;msg&quot;/&gt;
</code></pre></div><ul><li>绑定属性</li></ul> <blockquote><p>动态绑定样式
class</p></blockquote> <ol><li>等于对象</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;div class=&quot;abc&quot; :class=&quot;{b:true}&quot;&gt;你好&lt;/div&gt;
</code></pre></div><ol start="2"><li>等于数组</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;div class=&quot;abc&quot; :class=&quot;['a','b',c]&quot;&gt;你好&lt;/div&gt;//c为data中定义的
</code></pre></div><p>style
等于对象或者数组</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div style='color:red' :style=&quot;{background:'blue'}&quot;&gt;
&lt;div style='color:red' :style=&quot;[{background:'red',color:'blue'}]&quot;&gt;
</code></pre></div><h2 id="computed"><a href="#computed" aria-hidden="true" class="header-anchor">#</a> computed</h2> <ul><li>methods getFullName()放取值表达式中会造成性能问题，每次其他数据更新都会重新执行这个方法</li> <li>computed也是通过Object.defineProperty来实现的，只有依赖的数据更新时才会执行（有缓存）</li></ul> <div class="language- extra-class"><pre class="language-text"><code>computed:{
  fullName(){
    return this.firstName+this.lastName;
  }
}
</code></pre></div><h3 id="watch实现computed"><a href="#watch实现computed" aria-hidden="true" class="header-anchor">#</a> watch实现computed</h3> <div class="language- extra-class"><pre class="language-text"><code>data:{
  firstName:'珠',
  lastName:'峰',
  fullName:'',
},
methods:{
  getFullName(){
    this.fullName=this.firstName+this.lastName;
  }
},
watch:{//相当于vm.$watch('firstname',()=&gt;{})
  //普通写法，需要mount来执行
  firstName(newValue){
    this.getFullName();
  },
  //其他写法
  firstName:{
    handler(newValue){
      this.getFullName();
    },
    //立即执行
    immediate:true
  }
  lastName(){
    this.getFullName();
  }
}
</code></pre></div><blockquote><p>computed和method的区别？
computed只有绑定的数据变了才会执行，method做绑定时所有数据变了都会执行</p></blockquote> <blockquote><p>computed和watch的区别？</p></blockquote> <ul><li>watch支持异步，可以实现一些简单的功能，一般会先考虑使用computed，不能再用watch</li></ul> <h3 id="computed实现双向绑定"><a href="#computed实现双向绑定" aria-hidden="true" class="header-anchor">#</a> computed实现双向绑定</h3> <div class="language- extra-class"><pre class="language-text"><code>全选：&lt;input type=&quot;checkbox&quot; v-model=&quot;checkAll&quot;&gt;
&lt;input type=&quot;checkbox&quot; v-for=&quot;(item,key) in checks&quot; v-model=&quot;item.value&quot; :key=&quot;key&quot;&gt;
data:{
  checks:[{value:true},{value:false},{value:true},]
},
computed:{
  checkAll:{
    get(){
      return this.checks.every(check=&gt;check.value)
    },
    set(kvalue){
      this.checks.forEach(check=&gt;check.value=value);
    }
  }
}
</code></pre></div><h2 id="生命周期"><a href="#生命周期" aria-hidden="true" class="header-anchor">#</a> 生命周期</h2> <p>初始化自己的生命周期，并且绑定自己的事件</p> <ul><li>this.$data
vm.data</li></ul> <h3 id="beforecreate"><a href="#beforecreate" aria-hidden="true" class="header-anchor">#</a> beforeCreate</h3> <p>实例尚未创建完成
初始化注入，和响应事件</p> <div class="language- extra-class"><pre class="language-text"><code>data:{
  a:1
},
beforeCreate(){
  console.log(this)//undefined
  console.log(this.$data)//undefined
}

</code></pre></div><h3 id="created"><a href="#created" aria-hidden="true" class="header-anchor">#</a> created</h3> <p>可以获取数据和调用方法</p> <div class="language- extra-class"><pre class="language-text"><code>create(){
  console.log(this)//存在
  console.log(this.$data)//{a:1}
}
</code></pre></div><h3 id="beforemount"><a href="#beforemount" aria-hidden="true" class="header-anchor">#</a> beforeMount</h3> <p>渲染前，第一次调用渲染函数执行，可以拿到data,method等</p> <h3 id="mounted（重要）"><a href="#mounted（重要）" aria-hidden="true" class="header-anchor">#</a> mounted（重要）</h3> <p>渲染后，可获取真实dom，一般ajax请求放在这儿。</p> <div class="language- extra-class"><pre class="language-text"><code>mounted(){
  console.log(this.$el.innerHTML);
}
</code></pre></div><h3 id="beforeupdate"><a href="#beforeupdate" aria-hidden="true" class="header-anchor">#</a> beforeUpdate</h3> <p>更新前</p> <div class="language- extra-class"><pre class="language-text"><code>beforeUpdate(){
  console.log(this.$el.innerHTML);
}
</code></pre></div><h3 id="updated"><a href="#updated" aria-hidden="true" class="header-anchor">#</a> updated</h3> <p>一般不要操作数据，否则可能会死循环
更新后</p> <div class="language- extra-class"><pre class="language-text"><code>updated(){
  console.log(this.$el.innerHTML);
}
</code></pre></div><h3 id="beforedestroy（重要）"><a href="#beforedestroy（重要）" aria-hidden="true" class="header-anchor">#</a> beforeDestroy（重要）</h3> <p>销毁前（当前实例还可以用），一般会放销毁定时器等解绑操作</p> <div class="language- extra-class"><pre class="language-text"><code>beforeDestroy(){
  console.log(this.$el.innerHTML);
}
</code></pre></div><h3 id="destroyed"><a href="#destroyed" aria-hidden="true" class="header-anchor">#</a> destroyed</h3> <p>销毁后（实例上的方法，监听，事件绑定都被移除）</p> <div class="language- extra-class"><pre class="language-text"><code>destroyed(){
  console.log(this.$el.innerHTML);
}
</code></pre></div><blockquote><p>什么情况会走destroy?</p></blockquote> <ul><li><p>路由切换
一个组件切换到另一个组件，上一个组件要销毁</p></li> <li><p>vm.$destroy()
手动销毁</p></li></ul> <p><img src="/img/lifecycle.png" alt="vue生命周期"></p> <h2 id="组件-component"><a href="#组件-component" aria-hidden="true" class="header-anchor">#</a> 组件(component)</h2> <h3 id="组件化开发的优点："><a href="#组件化开发的优点：" aria-hidden="true" class="header-anchor">#</a> 组件化开发的优点：</h3> <ul><li><p>一个页面分为几个组件开发，方便协作，方便维护，可复用</p></li> <li><p>要采用闭合标签</p></li> <li><p>为了每个组件的数据，互不影响，data采用函数</p></li></ul> <h3 id="全局组件"><a href="#全局组件" aria-hidden="true" class="header-anchor">#</a> 全局组件</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id='app'&gt;
  &lt;my-button&gt;&lt;/my-button&gt;
  &lt;my-button&gt;&lt;/my-button&gt;
  &lt;my-button&gt;&lt;/my-button&gt;
&lt;/div&gt;
&lt;script&gt;
  //组件实际上就是个对象
  Vue.component('my-button',{
    template:`&lt;button&gt;{{msg}}&lt;/button&gt;`,
    data(){
      return {
        msg:'点我啊'
      }
    }
  })
  //根实例，也是一个组件
  let vm=new Vue({
    el:'#app',
  })
&lt;/script&gt;
</code></pre></div><h3 id="局部组件"><a href="#局部组件" aria-hidden="true" class="header-anchor">#</a> 局部组件</h3> <p>声明在某个组件之内</p> <ul><li>子组件在父组件的模板中使用</li> <li>组件名定义时写大驼峰，使用时用<code>-</code>连接，因为html标签不能有大写字母</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//父组件
&lt;div id='app'&gt;
  &lt;my-button&gt;&lt;/my-button&gt;
  &lt;my-button&gt;&lt;/my-button&gt;
  &lt;my-button&gt;&lt;/my-button&gt;
&lt;/div&gt;
let vm = new Vue({
  el:&quot;#app&quot;,
  //子组件
  components:{
    'MyButton':{
      data(){
        return {msg:'点我啊'}
      },
      template:`&lt;button&gt;{{}}&lt;/button&gt;`
    }
  }
})
</code></pre></div><h3 id="组件交互"><a href="#组件交互" aria-hidden="true" class="header-anchor">#</a> 组件交互</h3> <p>prop</p> <h4 id="prop传值"><a href="#prop传值" aria-hidden="true" class="header-anchor">#</a> prop传值</h4> <ul><li>简单传值</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Vue.component('blog-post', {
  props: ['title'],
  template: '&lt;h3&gt;{{ title }}&lt;/h3&gt;'
})

&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;
&lt;blog-post title=&quot;Blogging with Vue&quot;&gt;&lt;/blog-post&gt;
&lt;blog-post title=&quot;Why Vue is so fun&quot;&gt;&lt;/blog-post&gt;

My journey with Vue
Blogging with Vue
Why Vue is so fun
</code></pre></div><ul><li>传一个数组</li></ul> <div class="language- extra-class"><pre class="language-text"><code>new Vue({
  el: '#blog-post-demo',
  data: {
    posts: [
      { id: 1, title: 'My journey with Vue' },
      { id: 2, title: 'Blogging with Vue' },
      { id: 3, title: 'Why Vue is so fun' }
    ]
  }
})

&lt;blog-post
  v-for=&quot;post in posts&quot;
  v-bind:key=&quot;post.id&quot;
  v-bind:title=&quot;post.title&quot;
&gt;&lt;/blog-post&gt;
</code></pre></div><h4 id="this-attrs"><a href="#this-attrs" aria-hidden="true" class="header-anchor">#</a> this.$attrs</h4> <p>没有使用的属性</p> <h4 id="prop大小写"><a href="#prop大小写" aria-hidden="true" class="header-anchor">#</a> prop大小写</h4> <p>当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名</p> <div class="language- extra-class"><pre class="language-text"><code>Vue.component('blog-post', {
  // 在 JavaScript 中是 camelCase 的
  props: ['postTitle'],
  template: '&lt;h3&gt;{{ postTitle }}&lt;/h3&gt;'
})
&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;
&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt;
</code></pre></div><h4 id="prop类型"><a href="#prop类型" aria-hidden="true" class="header-anchor">#</a> prop类型</h4> <p>每个 prop 都有指定的值类型,可以以对象形式列出 prop，这些属性的名称和值分别是 prop 各自的名称和类型</p> <div class="language- extra-class"><pre class="language-text"><code>props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // or any other constructor
}
</code></pre></div><h4 id="传递静态或动态-prop"><a href="#传递静态或动态-prop" aria-hidden="true" class="header-anchor">#</a> 传递静态或动态 Prop</h4> <ul><li>静态prop</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;
</code></pre></div><ul><li>动态prop</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 动态赋予一个变量的值 --&gt;
&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;

&lt;!-- 动态赋予一个复杂表达式的值 --&gt;
&lt;blog-post
  v-bind:title=&quot;post.title + ' by ' + post.author.name&quot;
&gt;&lt;/blog-post&gt;
</code></pre></div><h5 id="传入一个对象的所有属性"><a href="#传入一个对象的所有属性" aria-hidden="true" class="header-anchor">#</a> 传入一个对象的所有属性</h5> <p>如果你想要将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 v-bind</p> <div class="language- extra-class"><pre class="language-text"><code>post: {
  id: 1,
  title: 'My Journey with Vue'
}
</code></pre></div><p>下面的模板：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt;
</code></pre></div><p>等价于：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;blog-post
  v-bind:id=&quot;post.id&quot;
  v-bind:title=&quot;post.title&quot;
&gt;&lt;/blog-post&gt;
</code></pre></div><h5 id="禁用特性继承"><a href="#禁用特性继承" aria-hidden="true" class="header-anchor">#</a> 禁用特性继承</h5> <div class="language- extra-class"><pre class="language-text"><code>Vue.component('my-component', {
  inheritAttrs: false,//没有用到的属性，不会显示在dom结构上了
  //
  template:`&lt;div&gt;my-button &lt;my v-bind=&quot;$attrs&quot;&gt;&lt;/my&gt;&lt;/div&gt;`,
  components:{
    'my':{
      props:['a','b'],
      template:`&lt;span&gt;{{a}} {{b}}&lt;/span&gt;`
    }
  }
})
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let vm=new Vue({
  el:'#app',
  data:{
    content:'点我啊'
  },
  components:{
    'MyButton':{
      mounted(){
        //对没有使用的属性 把他保留在this.$attrs中
        console.log(this.$attrs)
      },
      inheritAttrs:false,//没有用到的数据，就不会显示在dom结构上了
      template:`&lt;div&gt;my-button &lt;my v-bind=&quot;$attrs&quot;&gt;&lt;/my&gt;&lt;/div&gt;`,
      components:{
        'my':{
          props:['a','b'],
          template:`&lt;span&gt;{{a}}{{b}}&lt;/span&gt;`
        }
      }
    }
  }
})
</code></pre></div><h5 id="props"><a href="#props" aria-hidden="true" class="header-anchor">#</a> props</h5> <div class="language- extra-class"><pre class="language-text"><code>&lt;my-button :a=&quot;1&quot; b=&quot;2&quot; :arr=&quot;[1,2,3]&quot;&gt;&lt;/my-button&gt;
componets:{
  'MyButton':{
    props:{
      msg:{
        type:String,
        default:'点我啊'
      },
      a:{
        type:Number
      },
      b:{}
    },
    template:`&lt;button&gt;{{msg}}{{a}}{{b}}&lt;/button&gt;`
  }
}

</code></pre></div></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/frontend/css.html" class="prev">
          css
        </a></span> <span class="next"><a href="/frontend/webpack.html">
          webpack
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.1dc331ee.js" defer></script><script src="/assets/js/23.50f603d8.js" defer></script>
  </body>
</html>
