<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue 源码 | yy3535</title>
    <meta name="description" content="yy3535的笔记">
    <link rel="icon" href="/img/favicon.ico">
  <script src="/img/类图.png"></script>
    
    <link rel="preload" href="/assets/css/0.styles.8ddfe154.css" as="style"><link rel="preload" href="/assets/js/app.54eabcd6.js" as="script"><link rel="preload" href="/assets/js/16.5961a583.js" as="script"><link rel="prefetch" href="/assets/js/10.0853ae68.js"><link rel="prefetch" href="/assets/js/11.b9985e6d.js"><link rel="prefetch" href="/assets/js/12.6fefd4f6.js"><link rel="prefetch" href="/assets/js/13.cfa1c025.js"><link rel="prefetch" href="/assets/js/14.d227cc55.js"><link rel="prefetch" href="/assets/js/15.d3faaa33.js"><link rel="prefetch" href="/assets/js/17.f092c717.js"><link rel="prefetch" href="/assets/js/18.860a856a.js"><link rel="prefetch" href="/assets/js/19.38358f74.js"><link rel="prefetch" href="/assets/js/2.ecd83188.js"><link rel="prefetch" href="/assets/js/20.55864488.js"><link rel="prefetch" href="/assets/js/21.c0cc03fc.js"><link rel="prefetch" href="/assets/js/22.1dc369bb.js"><link rel="prefetch" href="/assets/js/23.5515ea0e.js"><link rel="prefetch" href="/assets/js/24.fc3a77fc.js"><link rel="prefetch" href="/assets/js/25.675f54ba.js"><link rel="prefetch" href="/assets/js/26.a6c3ed35.js"><link rel="prefetch" href="/assets/js/27.bb996256.js"><link rel="prefetch" href="/assets/js/28.811fb759.js"><link rel="prefetch" href="/assets/js/29.3626bae6.js"><link rel="prefetch" href="/assets/js/3.4579d918.js"><link rel="prefetch" href="/assets/js/30.94ad3a81.js"><link rel="prefetch" href="/assets/js/31.842c6b61.js"><link rel="prefetch" href="/assets/js/32.6e36f6d7.js"><link rel="prefetch" href="/assets/js/33.e82ebfdb.js"><link rel="prefetch" href="/assets/js/34.1681b4ce.js"><link rel="prefetch" href="/assets/js/35.23e593b9.js"><link rel="prefetch" href="/assets/js/36.31dc639e.js"><link rel="prefetch" href="/assets/js/37.f79fbbc9.js"><link rel="prefetch" href="/assets/js/38.62d03b75.js"><link rel="prefetch" href="/assets/js/39.cf67fbae.js"><link rel="prefetch" href="/assets/js/4.ab2d1efe.js"><link rel="prefetch" href="/assets/js/40.09377808.js"><link rel="prefetch" href="/assets/js/41.f8296ab4.js"><link rel="prefetch" href="/assets/js/42.1265ac20.js"><link rel="prefetch" href="/assets/js/43.3571ae05.js"><link rel="prefetch" href="/assets/js/44.b57ff5e4.js"><link rel="prefetch" href="/assets/js/45.776efbf7.js"><link rel="prefetch" href="/assets/js/46.8f68f79a.js"><link rel="prefetch" href="/assets/js/47.4b737978.js"><link rel="prefetch" href="/assets/js/48.9be0756b.js"><link rel="prefetch" href="/assets/js/49.df17763c.js"><link rel="prefetch" href="/assets/js/5.14cca89b.js"><link rel="prefetch" href="/assets/js/50.fde13d0e.js"><link rel="prefetch" href="/assets/js/51.7563fd6e.js"><link rel="prefetch" href="/assets/js/52.2311d979.js"><link rel="prefetch" href="/assets/js/53.bc9ec8ea.js"><link rel="prefetch" href="/assets/js/54.d6905baf.js"><link rel="prefetch" href="/assets/js/55.b5585ac6.js"><link rel="prefetch" href="/assets/js/56.f930916d.js"><link rel="prefetch" href="/assets/js/57.b574bfe0.js"><link rel="prefetch" href="/assets/js/58.e7e25e21.js"><link rel="prefetch" href="/assets/js/59.fac50d23.js"><link rel="prefetch" href="/assets/js/6.04fba932.js"><link rel="prefetch" href="/assets/js/7.17723601.js"><link rel="prefetch" href="/assets/js/8.de523f4b.js"><link rel="prefetch" href="/assets/js/9.8c5c37b3.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8ddfe154.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.jpg" alt="yy3535" class="logo"> <span class="site-name can-hide">yy3535</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Frontend/" class="nav-link router-link-active">前端</a></div><div class="nav-item"><a href="/Backend/" class="nav-link">后端</a></div><div class="nav-item"><a href="/Operation/" class="nav-link">运维</a></div><div class="nav-item"><a href="https://github.com/yy3535/yy3535" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Frontend/" class="nav-link router-link-active">前端</a></div><div class="nav-item"><a href="/Backend/" class="nav-link">后端</a></div><div class="nav-item"><a href="/Operation/" class="nav-link">运维</a></div><div class="nav-item"><a href="https://github.com/yy3535/yy3535" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading"><span>html/css</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Frontend/css.html" class="sidebar-link">【1. HTML和css】</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>js</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Frontend/js/jsbasic/" class="sidebar-link">【2. JS基础】</a></li><li><a href="/Frontend/js/jssenior/" class="sidebar-link">JS高级</a></li><li><a href="/Frontend/js/jsbasic/zepto.html" class="sidebar-link">zepto源码解读</a></li><li><a href="/Frontend/js/jsbasic/shenrubibao.html" class="sidebar-link">深入理解javascript原型链和闭包</a></li><li><a href="/Frontend/js/jswebapi/" class="sidebar-link">【3. JS-WEB-API】</a></li><li><a href="/Frontend/js/devenv/" class="sidebar-link">【4. 开发环境】</a></li><li><a href="/Frontend/js/runenv/" class="sidebar-link">【5. 运行环境】</a></li><li><a href="/Frontend/js/es6/" class="sidebar-link">【6. ES6】</a></li><li><a href="/Frontend/js/designpatterns/" class="sidebar-link">前端设计模式</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>vue</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Frontend/vue.html" class="sidebar-link">【7. vue】</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading open"><span>vuesource</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Frontend/vuesource.html" class="active sidebar-link">vue 源码</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#准备工作" class="sidebar-link">准备工作</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#flow" class="sidebar-link">Flow</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#vue-js-源码构建" class="sidebar-link">Vue.js 源码构建</a></li></ul></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#nexttick" class="sidebar-link">nextTick</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#核心点mvvm和dom-diff" class="sidebar-link">核心点MVVM和DOM-diff</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#vue对象劫持" class="sidebar-link">vue对象劫持</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#数组劫持" class="sidebar-link">数组劫持</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#编译文本" class="sidebar-link">编译文本</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#依赖收集" class="sidebar-link">依赖收集</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#异步批量更新" class="sidebar-link">异步批量更新</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#数组的依赖收集更新？？" class="sidebar-link">数组的依赖收集更新？？</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#watch" class="sidebar-link">watch??</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#computed" class="sidebar-link">computed</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#虚拟dom和初次渲染，子节点比较" class="sidebar-link">虚拟dom和初次渲染，子节点比较</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#虚拟dom融合vue代码" class="sidebar-link">虚拟dom融合vue代码</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#vue源码剖析" class="sidebar-link">Vue源码剖析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#一-目录源码剖析" class="sidebar-link">一.目录源码剖析</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#二-如何看vue源代码" class="sidebar-link">二.如何看Vue源代码</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#三-vue的初始化工作" class="sidebar-link">三.Vue的初始化工作</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#四-数据响应式原理" class="sidebar-link">四.数据响应式原理</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#五-计算属性的实现" class="sidebar-link">五.计算属性的实现</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#六-watch的实现原理" class="sidebar-link">六.Watch的实现原理</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#七-dom-diff原理" class="sidebar-link">七.Dom-Diff原理</a></li></ul></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#总结图" class="sidebar-link">总结图</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#实现broadcast" class="sidebar-link">实现broadcast</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#组件" class="sidebar-link">组件</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#插件原理" class="sidebar-link">插件原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#vue-lazyload组件实现" class="sidebar-link">vue-lazyload组件实现</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#js垃圾收集" class="sidebar-link">JS垃圾收集</a></li><li class="sidebar-sub-header"><a href="/Frontend/vuesource.html#函数柯里化" class="sidebar-link">函数柯里化</a></li></ul></li></ul></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>react</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Frontend/react.html" class="sidebar-link">React</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>ts</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Frontend/typescript.html" class="sidebar-link">TypeScript</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>webpack</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Frontend/webpack.html" class="sidebar-link">【8. webpack】</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>JS数据结构与算法</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Frontend/algorithm.html" class="sidebar-link">【9. 前端算法】</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>前端知识点大纲</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Frontend/viewskills.html" class="sidebar-link">【10. 总结】</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>小工具</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Frontend/vuepress.html" class="sidebar-link">vuepress</a></li><li><a href="/Frontend/markdown.html" class="sidebar-link">markdown</a></li><li><a href="/Frontend/github.io.html" class="sidebar-link">github.io网站搭建</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>自动化测试</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Frontend/automatedTest.html" class="sidebar-link">js单元测试的一门语言Jest</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Frontend/other.html" class="sidebar-link">其他</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="vue-源码"><a href="#vue-源码" aria-hidden="true" class="header-anchor">#</a> vue 源码</h1> <p><a href="https://github.com/ustbhuangyi/vue-analysis" target="_blank" rel="noopener noreferrer">电子书<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="准备工作"><a href="#准备工作" aria-hidden="true" class="header-anchor">#</a> 准备工作</h2> <h3 id="flow"><a href="#flow" aria-hidden="true" class="header-anchor">#</a> Flow</h3> <p>Flow 是 facebook 出品的 JavaScript 静态类型检查工具。</p> <h4 id="为什么用-flow"><a href="#为什么用-flow" aria-hidden="true" class="header-anchor">#</a> 为什么用 Flow</h4> <p>JavaScript 是动态类型语言，它的灵活性有目共睹，但是过于灵活的副作用是很容易就写出非常隐蔽的隐患代码，在编译期甚至看上去都不会报错，但在运行阶段就可能出现各种奇怪的 bug。</p> <p>类型检查是当前动态类型语言的发展趋势，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验。</p> <h4 id="flow-的工作方式"><a href="#flow-的工作方式" aria-hidden="true" class="header-anchor">#</a> Flow 的工作方式</h4> <p>通常类型检查分成 2 种方式：</p> <p>类型推断：通过变量的使用上下文来推断出变量类型，然后根据这些推断来检查类型。</p> <p>类型注释：事先注释好我们期待的类型，Flow 会基于这些注释来判断。</p> <ul><li>类型推断</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/*@flow*/</span>

<span class="token keyword">function</span> <span class="token function">split</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">split</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>类型注释</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/*@flow*/</span>

<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> y
<span class="token punctuation">}</span>

<span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/*@flow*/</span>

<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> number<span class="token punctuation">,</span> y<span class="token punctuation">:</span> number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> number <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> y
<span class="token punctuation">}</span>

<span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="flow-在-vue-js-源码中的应用"><a href="#flow-在-vue-js-源码中的应用" aria-hidden="true" class="header-anchor">#</a> Flow 在 Vue.js 源码中的应用</h4> <div class="language- extra-class"><pre class="language-text"><code>npm install -g flow-bin
flow init // 创建.flowconfig配置文件
flow
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>flow
├── compiler.js        # 编译相关
├── component.js       # 组件数据结构
├── global-api.js      # Global API 结构
├── modules.js         # 第三方库定义
├── options.js         # 选项相关
├── ssr.js             # 服务端渲染相关
├── vnode.js           # 虚拟 node 相关
</code></pre></div><p>可以看到，Vue.js 有很多自定义类型的定义，在阅读源码的时候，如果遇到某个类型并想了解它完整的数据结构的时候，可以回来翻阅这些数据结构的定义。</p> <h3 id="vue-js-源码构建"><a href="#vue-js-源码构建" aria-hidden="true" class="header-anchor">#</a> Vue.js 源码构建</h3> <p>Vue.js 源码是基于 Rollup 构建的，它的构建相关配置都在 scripts 目录下。</p> <h2 id="nexttick"><a href="#nexttick" aria-hidden="true" class="header-anchor">#</a> nextTick</h2> <p>重看nextTick 派发更新 依赖</p> <h1 id="珠峰vue源码"><a href="#珠峰vue源码" aria-hidden="true" class="header-anchor">#</a> 珠峰vue源码</h1> <h2 id="核心点mvvm和dom-diff"><a href="#核心点mvvm和dom-diff" aria-hidden="true" class="header-anchor">#</a> 核心点MVVM和DOM-diff</h2> <ul><li>vue中如何实现数据劫持</li> <li>数组得劫持</li> <li>vue中的观察者模式</li> <li>计算属性和watch的区别（原理）</li> <li>vue中数据的批量更新</li> <li>nextTick原理</li> <li>什么是虚拟dom及虚拟dom的作用</li> <li>vue中的diff实现</li></ul> <h2 id="vue对象劫持"><a href="#vue对象劫持" aria-hidden="true" class="header-anchor">#</a> vue对象劫持</h2> <ol><li>使用构造函数来写vue，因为这种方式可以分多个文件来给Vue类添加方法，结构清晰明了</li> <li>_init(options)初始化--&gt;initState(vm) MVVM数据重新初始化--&gt;initData 重新初始化data--&gt;observe(data) 观察数据--&gt;new Observer()--&gt;this.walk--&gt;defineReactive--&gt;Object.defineProperty()(注意此时要对value observe(value)进行递归观察，set中也要对更新的值递归观察)</li> <li>去掉取值时vm._data.msg的data(vm._data为之前的观察数据)：initData--&gt;proxy(vm,'_data',key) （vm上的数据代理为vm_data上的数据）--&gt;Object.defineProperty()--&gt;return vm['_data'][key] vm['_data'][key]=newValue</li></ol> <h2 id="数组劫持"><a href="#数组劫持" aria-hidden="true" class="header-anchor">#</a> 数组劫持</h2> <ol><li>以上代码数组的增删，set无法观察到。需要对原生的方法进行劫持</li> <li>Observer--&gt;isArray--&gt;Object.create()新建对象复制原数组方法--&gt;给复制的方法赋值一个函数，函数中调用老的方法(函数劫持，切片编程)。data的__proto__指向新对象。</li> <li>数组中添加了对象：observerArray(inserted) 对数组观测 --&gt;observe(inserted[i]) 对添加的每一个成员观测</li> <li>数组劫持观测数据两个缺点：[0,1,2]直接改变索引下不能被监测到，[1,2,3].length--,长度变化不会监测到</li> <li>数组劫持可以监测到：数组里的对象可以监测，push/splice/unshift可以监测</li></ol> <h2 id="编译文本"><a href="#编译文本" aria-hidden="true" class="header-anchor">#</a> 编译文本</h2> <ol><li>_init(options)初始化--&gt;vm.$mount()--&gt;document.querySelector拿到组件--&gt;new Watcher(vm,updateComponent())--&gt;_update()--&gt;document.createDocumentFragment()(操作文档碎片，减少真实dom的操作导致的渲染)--&gt;node.appendChild(firstChild)将真实dom移动到文档碎片中（vue1.0的做法）</li> <li>compiler--&gt;文本节点：compilerText--&gt;replace--&gt;（reduce迭代data.school.name获得value）</li> <li>compiler--&gt;元素节点：compiler()</li> <li>编译完后放回真实dom中 el.appendChild(node)</li></ol> <h2 id="依赖收集"><a href="#依赖收集" aria-hidden="true" class="header-anchor">#</a> 依赖收集</h2> <p>使用Dep类来收集依赖，收集一个个watcher，需要更新时再把watcher全部执行</p> <ol><li>vm.$mount()--&gt;new Watcher(vm,updateComponent())</li> <li>this.get()--&gt;pushTarget(this) target指向当前watch</li> <li>this.getter.call(this.vm)--&gt;vm._update(vm._render())--&gt;调用当前属性的get方法--&gt;dep.addSub(watcher)</li> <li>修改数据后--&gt;set()--&gt;dep.notify()--&gt;this.subs.forEach(watcher=&gt;watcher.update())=&gt;update--&gt;this.get()--&gt;重新渲染</li> <li>popTarget() target置为空</li> <li>?????? 同一个data如果调用多次会有多个watcher，会更新时多次渲染：defineReactive--&gt;get()--&gt;dep.depend()(让dep中可以存watcher,watcher中可以存dep,实现多对多的关系)--&gt;Dep.target.addDep(this)--&gt;
？？？？</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> id<span class="token operator">=</span>dep<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>depsId<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>depsId<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 让watcher记住当前的dep</span>
  dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="异步批量更新"><a href="#异步批量更新" aria-hidden="true" class="header-anchor">#</a> 异步批量更新</h2> <p>nextTick实现原理：</p> <ol><li><p>短时间内多次给一个data赋值，会多次渲染更新，影响性能，需要批量更新。如果立即调用get，会导致页面刷新，需要异步来更新：new Watcher--&gt;update--&gt;queueWatcher(this)--&gt;批量更新的都是同一个watcher，所以对重复的watcher进行过滤操作--&gt;queue.push(watcher)--&gt;实现异步更新 nextTick(flushQueue)--&gt;flushQueue 更新 --&gt;queue.forEach(watcher=&gt;watcher.run())</p></li> <li><p>nextTick-&gt;先使用异步微任务(promise没有再使用 mutationObserver)没有再使用异步宏任务(setImmediate没有再使用setTimeout)</p></li></ol> <h2 id="数组的依赖收集更新？？"><a href="#数组的依赖收集更新？？" aria-hidden="true" class="header-anchor">#</a> 数组的依赖收集更新？？</h2> <ol><li>对象数组是可以依赖收集的，但是push/unshift/splice不能收集依赖</li> <li>Observer--&gt;this.dep=new Dep()--&gt;isArray</li></ol> <h2 id="watch"><a href="#watch" aria-hidden="true" class="header-anchor">#</a> watch??</h2> <ol><li>initState--&gt;initWatch(vm)--&gt;createWatcher(vm,key,handler)--&gt;return vm.$watch(key,handler)</li> <li>this.$watch的实现
Vue.prototype.$watch(expr,$watch)--&gt;new Watcher(vm,expr,handler,{user:true}) 叫用户watcher--&gt;this.value=this.get() 取老值--&gt;run之后拿到更新后的值 let value=this.get()--&gt;如果新值和老值不一样，就调用回调函数</li></ol> <h2 id="computed"><a href="#computed" aria-hidden="true" class="header-anchor">#</a> computed</h2> <ol><li>initState--&gt;initComputed(vm,opts.computed)--&gt;watcher=vm._watchersComputed=Object.create(null) 创建一个对象存储计算属性的watcher对象,并将计算属性的配置放到vm上</li> <li>new Watcher(vm,userDef,()=&gt;{},{lazy:true}) 创建计算属性watcher,lazy dirty都配置true--&gt;this.value=this.lazy?undefined:this.get() 默认值是undefined</li> <li>Object.defineProperty(vm,key,{get:createComputedGetter(vm,key)}) 当用户在取值模板上写了表达式之后，取值时就会走到这个表达式里--&gt;如果有watcher,有计算属性，--&gt;dirty是true--&gt;watcher.evaluate() 求值--&gt;this.get()--&gt;pushTarget(this) 把计算属性watcher放入watcher栈，所以现在栈中有一个渲染watcher和一个计算属性watcher,Dep.target是栈中最后一个即计算属性watcher--&gt;this.getter.call(this.vm)执行计算属性方法，--&gt;栈中计算属性watcher pop出去，Dep.target为渲染watcher,Dep.target有值得时候，两个属性会都收集渲染watcher，所以数据变化后，会先执行计算属性watcher,再执行渲染watcher watcher.depend()--&gt;this.deps[i].depend()--&gt;watcher--&gt;dirty=false 值求过了，下次渲染不用求了</li> <li>值有变化时--&gt;watcher.js update()--&gt;dirty=true 计算属性依赖的值变化了 稍后取值时重新计算</li> <li>watcher.update--&gt;if(this.lazy){this.dirty=false} 会在页面重新取值，但不重新渲染，需要再加一个渲染watcher</li> <li>observe--&gt;if(watcher)--&gt;if(Dep.target){watcher.depend()} 如果有计算属性watcher,就在两个dep里分别存入渲染watcher</li> <li>watcher.js--&gt;depend(){let deps=this.deps.length}--&gt;this.deps[i].depend()</li></ol> <h2 id="虚拟dom和初次渲染，子节点比较"><a href="#虚拟dom和初次渲染，子节点比较" aria-hidden="true" class="header-anchor">#</a> 虚拟dom和初次渲染，子节点比较</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>h<span class="token punctuation">,</span>render<span class="token punctuation">,</span>patch<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./vdom'</span><span class="token punctuation">;</span>
<span class="token comment">// h=&gt;createElement 用于来创建元素的方法 返回值是一个虚拟dom</span>
<span class="token comment">// render 将虚拟dom渲染成真实节点，并放到某个容器中</span>
<span class="token comment">// patch 比对两个虚拟节点 并且用新的节点去更新老的节点</span>
<span class="token keyword">let</span> oldVnode<span class="token operator">=</span><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token string">'container'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>style<span class="token punctuation">:</span><span class="token punctuation">{</span>color<span class="token punctuation">:</span><span class="token string">'red'</span><span class="token punctuation">,</span>background<span class="token punctuation">:</span><span class="token string">'yellow'</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token string">'zf'</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> container<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">render</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> newVnode<span class="token operator">=</span><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token string">'aa'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>style<span class="token punctuation">:</span><span class="token punctuation">{</span>color<span class="token punctuation">:</span><span class="token string">'green'</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token string">'px'</span>
<span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  <span class="token comment">// 新节点和老节点对比，更新真实dom元素</span>
  <span class="token function">patch</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span>newVnode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>vue2.0使用虚拟dom实现编译</li> <li>操作文档碎片性能低，所以自己构建虚拟dom节点对象来编译。
<ol><li>虚拟dom内容比实际dom内容少得多。</li> <li>虚拟dom可以实现dom之前和之后的比对，减少更新，不用直接替换</li></ol></li></ul> <div class="tip custom-block"><p class="custom-block-title">返回的虚拟dom对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  tag<span class="token punctuation">:</span><span class="token string">'div'</span><span class="token punctuation">,</span>
  props<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  children<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span>
    tag<span class="token punctuation">:</span><span class="token keyword">undefined</span><span class="token punctuation">,</span>
    props<span class="token punctuation">:</span><span class="token keyword">undefined</span><span class="token punctuation">,</span>
    children<span class="token punctuation">:</span><span class="token keyword">undefined</span><span class="token punctuation">,</span>
    text<span class="token punctuation">:</span><span class="token string">'hello'</span>
  <span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>hello<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ol><li>h(tag,props,...children)--&gt;return vnode(tag,props,key,children)--&gt;return vnode对象</li> <li>将vnode渲染成真实dom挂在到页面上。返回渲染完的dom</li></ol> <ul><li>render(vnode,container)--&gt;vnode.el=createElm(vnode)--&gt;updateProperties()--&gt;style老的有，新的没有，el.style[key]=''。props老的里有，新的里没有，delete el[key]--&gt;属性是style，el.style[stylename]=newProps.style[stylename]--&gt;都不是 el[key]=newProps[key]--&gt;document.createElement/document.createTextNode(text)</li> <li>appendChild</li> <li>return el</li></ul> <ol start="3"><li>patch(oldVnode,newVnode) 比较新旧虚拟节点 并尽量少地渲染新节点更新页面 返回新dom元素</li> <li>标签不一样直接替换成新节点 oldVnode.el.parentNode.replaceChild(createEle(newVnode),oldVnode)
<ol><li>标签一样，当前标签是undefined，内容不一样，就文本内容替换 oldVnode.el.textContent=newVnode.test</li> <li>标签一样，属性不一样 let el=newVnode.el=oldVnode.el 复用--&gt;updateProperties(newVnode,oldVnode.props) 做属性的比对</li> <li>比较children
<ol><li>老的有孩子 新的有孩子
<ol><li>updateChildren(el,oldChildren,newChildren)
while(oldStartIndex&lt;=oldEndIndex&amp;&amp;newStartIndex&lt;=newEndIndex)--&gt;
<ol><li>添加元素、删除元素
<ol><li>从后面添加元素
四个指针，前面的指针一起往后退，判断是否一样，一样就往后退一个，直到老的头指针到结尾了，就把新增的这一段添加到新节点中去，或者把旧的一段删除 isSameVNode(oldStartVnode,newStartVnode)--&gt;return (oldVnode.tag===newVnode.tag)&amp;&amp;(oldVnode.key===newVnode.key)--&gt;patch(oldStartVnode,newStartVnode) 用新的属性更新老的属性--&gt;oldStartVnode=oldChildren[++oldStartIndex]
--&gt;newStartVnode=newChildren[++newStartIndex] 让指针后移并且Vnode赋为现在的值
--&gt;newStartIndex&lt;=newEndIndex 添加的情况--&gt;parent.appendChild(createElm(newChildren[i])) 把新的剩下的放进旧的
--&gt; 删除的情况</li> <li>从前面添加元素
使用尾指针重复以上步骤，插入插在头部 insertBefore(插入的元素，参考位置节点)</li></ol></li> <li>排列正序、排列倒序
<ol><li>倒序：拿老的头指针和新的尾指针比较，如果相同就把老的第一个元素移到老的尾指针后面</li> <li>正序：拿老的尾指针和新的头指针比较，如果相同就把老的最后一个元素移到老的头指针前面</li></ol></li></ol></li></ol></li> <li>老的有孩子 新的没孩子
<ol><li>el.innerHTML=''</li></ol></li> <li>老的没孩子 新的有孩子
<ol><li>let child=newChildren[i]</li> <li>el.appendChild(createElm(child)) 将新的儿子放入老节点中</li></ol></li></ol></li></ol></li></ol> <div class="tip custom-block"><p class="custom-block-title">为什么不能使用索引作为key</p> <p>比如倒序的情况abcd变成dcba，最佳情况是abc移动三次即可完成更新。如果使用索引，abcd四个位置不变，但内容全部要更新，渲染四次（创建新节点并替换）。移动三次比渲染四次性能高太多。</p></div></div> <h2 id="虚拟dom融合vue代码"><a href="#虚拟dom融合vue代码" aria-hidden="true" class="header-anchor">#</a> 虚拟dom融合vue代码</h2> <p>vm.$mount()--&gt;vm._update(vm._render())--&gt;let render=vm.$options.render 获取用户写的render方法--&gt;let vnode=render.call(vm,h) return vnode 执行用户的render方法 返回vnode
vm._update(vnode)--&gt;初次渲染 vm.$el=render(vnode,el)--&gt;更新操作 let $el=patch(preVnode,vnode)</p> <h2 id="vue源码剖析"><a href="#vue源码剖析" aria-hidden="true" class="header-anchor">#</a> <code>Vue</code>源码剖析</h2> <h3 id="一-目录源码剖析"><a href="#一-目录源码剖析" aria-hidden="true" class="header-anchor">#</a> 一.目录源码剖析</h3> <ul><li><p><code>compiler</code>(编译模块) 将模板<code>template</code>转化成<code>render</code>函数</p></li> <li><p><code>core</code>  (核心模块 )</p> <ul><li><p><code>components</code> 内置的组件</p></li> <li><p><code>global-api</code> 全局的<code>api</code></p></li> <li><p><code>instance</code> <code>Vue</code>实例相关的核心逻辑</p></li> <li><p><code>observer</code> <code>Vue</code>中<code>MVVM</code>响应式数据原理</p></li> <li><p><code>util</code>核心模块中的工具方法</p></li> <li><p><code>vdom</code> 虚拟<code>dom</code>模块</p></li></ul></li> <li><p><code>platform</code>(平台模块) 通过不同入口编译出不同的<code>vue.js</code></p> <ul><li><code>web</code> 浏览器中使用的<code>vue</code></li> <li><code>weex</code> <code>weex</code> 基于<code>vue</code>的移动端跨平台<code>ui</code></li></ul></li> <li><p><code>server</code> 服务端渲染相关代码</p></li> <li><p><code>sfc</code> 将<code>.vue</code> 文件编译成对象</p></li> <li><p><code>shared</code> 所有模块中共享的方法</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>src
├── compiler        # 编译模块 
├── core            # 核心模块 
├── platforms       # 平台模块
├── server          # 服务端渲染
├── sfc             # .vue 文件编译成对象
├── shared          # 所有模块中的共享代码
</code></pre></div><h4 id="compiler"><a href="#compiler" aria-hidden="true" class="header-anchor">#</a> compiler</h4> <p>compiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。</p> <p>编译的工作可以在构建时做（借助 webpack、vue-loader 等辅助插件）；也可以在运行时做，使用包含构建功能的 Vue.js。显然，编译是一项耗性能的工作，所以更推荐前者——离线编译。</p> <h4 id="core"><a href="#core" aria-hidden="true" class="header-anchor">#</a> core</h4> <p>core 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。</p> <h4 id="platform"><a href="#platform" aria-hidden="true" class="header-anchor">#</a> platform</h4> <p>Vue.js 是一个跨平台的 MVVM 框架，它可以跑在 web 上，也可以配合 weex 跑在 native 客户端上。platform 是 Vue.js 的入口，2 个目录代表 2 个主要入口，分别打包成运行在 web 上和 weex 上的 Vue.js。</p> <h4 id="server"><a href="#server" aria-hidden="true" class="header-anchor">#</a> server</h4> <p>Vue.js 2.0 支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。注意：这部分代码是跑在服务端的 Node.js，不要和跑在浏览器端的 Vue.js 混为一谈。</p> <p>服务端渲染主要的工作是把组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记&quot;混合&quot;为客户端上完全交互的应用程序。</p> <h4 id="sfc"><a href="#sfc" aria-hidden="true" class="header-anchor">#</a> sfc</h4> <p>通常我们开发 Vue.js 都会借助 webpack 构建， 然后通过 .vue 单文件来编写组件。</p> <p>这个目录下的代码逻辑会把 .vue 文件内容解析成一个 JavaScript 的对象。</p> <h4 id="shared"><a href="#shared" aria-hidden="true" class="header-anchor">#</a> shared</h4> <p>Vue.js 会定义一些工具方法，这里定义的工具方法都是会被浏览器端的 Vue.js 和服务端的 Vue.js 所共享的。</p> <h3 id="二-如何看vue源代码"><a href="#二-如何看vue源代码" aria-hidden="true" class="header-anchor">#</a> 二.如何看<code>Vue</code>源代码</h3> <ul><li>通过<code>package.json</code>来看项目入口
<ul><li><code>main</code> 默认引入包会查找<code>main</code>对应的文件(require引入)</li> <li><code>module</code> 如果使用<code>webpack</code>默认会以<code>module</code>对应的文件为入口(import引入)</li></ul></li></ul> <blockquote><p>打包出的结果会放到<code>dist</code>目录下，我们需要查找打包的命令在哪里?</p></blockquote> <p>通过<code>scripts</code>的脚本来进行打包,找到<code>build</code>的相关字段</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token string">&quot;build&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;node scripts/build.js&quot;</span> 
<span class="token string">&quot;build:ssr&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;npm run build -- web-runtime-cjs,web-server-renderer&quot;</span>
<span class="token string">&quot;build:weex&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;npm run build -- weex&quot;</span>
</code></pre></div><p>核心打包执行的文件是<code>build.js</code></p> <p><strong>打包的模块类型</strong></p> <p>模块的区别:<code>cjs</code>(<code>commonjs</code>规范) 、<code>es</code>(<code>es6Module</code>)、<code>umd</code> (<code>Universal Module Definition</code>  )  （包含<code>AMD</code>、<code>cmd</code>、<code>CommonJs</code>）</p> <p><strong>分析打包流程</strong>：</p> <ul><li><p>1.先查看<code>dist</code>目录是否存在,如果不存在就创建此目录</p></li> <li><p>2.根据自己的配置生成<code>rollup</code>的配置</p></li> <li><p>3.根据用户打包时传递的参数过滤配置</p></li> <li><p>4.进行打包<code>roolup.rollup(config)</code> <code>入口在src-platforms-web-entry-runtime</code>,并且生成打包后的结果写入到目录中<code>write</code></p></li></ul> <p><code>Vue</code>的两种模式:<code>Runtime-Only</code> 不能在运行时编译模板只支持用户编写<code>render function</code>,<code>Runtime-with-Compiler</code>运行时可以编译模板文件体积大。</p> <p><strong>找到<code>Vue</code>的入口</strong>:</p> <p>以<code>Runtime-with-Compiler</code>为入口 找到,<code>platform/web/entry-runtime-with-compiler</code></p> <p>分析入口查找:</p> <ul><li>1.先找到<code>entry-runtime-with-compliler</code>,重写<code>$mount</code>方法</li> <li>2.找到<code>runtime/index</code> 主要包含<code>$mount</code>核心方法 (<code>__patch__</code>方法</li> <li>3.<code>core/index</code>在<code>Vue</code>的构造函数增加全局<code>api</code></li> <li>4.<code>instance/index</code>找到<code>Vue</code>的构造函数,给<code>Vue</code>构造函数增加多个原型方法</li></ul> <p><img src="/assets/img/constructor.f9dda84c.png" alt></p> <h3 id="三-vue的初始化工作"><a href="#三-vue的初始化工作" aria-hidden="true" class="header-anchor">#</a> 三.<code>Vue</code>的初始化工作</h3> <p>通过<code>demo</code>来找到真实引入的<code>Vue.js</code>文件 <code>vue/dist/vue.esm.js</code></p> <p><strong>分析初始化过程</strong>:</p> <ul><li><p>1.<code>new Vue</code>时会调用<code>_init</code>方法</p></li> <li><p>2.增加了<code>_uid</code>给每个实例增加唯一标识</p></li> <li><p>3.将用户的所有属性挂载到<code>vm.$options</code>上</p></li> <li><p>4.初始化状态 <code>initState()</code>将用户传递的属性挂载到<code>vm._data</code> 上并且代理到<code>vue</code>的实例上</p></li> <li><p>5.如果有<code>el</code>属性就进行挂载,并且调用<code>$mount</code>方法</p></li></ul> <p><strong>分析挂载流程</strong>:</p> <ul><li><p>1.如果用户使用<code>runtime-with-compiler</code>会调用他内部的<code>$mount</code>方法</p></li> <li><p>2.先判断是否有<code>render</code>方法,如果没有<code>render</code>会查找<code>template</code>并且将<code>template</code>变成<code>render</code>方法,如果没有<code>template</code>默认会使用<code>el</code>指定的<code>dom</code>元素</p></li> <li><p>3.调用<code>runtime/index</code>中的<code>$mount</code>方法,内部会统一处理调用<code>mountComponent</code></p></li> <li><p>4.会校验<code>render</code>方法的存在,并且会将当前的真实<code>dom</code>挂载到<code>vm.$el</code></p></li> <li><p>5.生成<code>updateComponent</code>方法,并且初始化渲染<code>watcher</code>,内部会立刻调用<code>updateComponent</code>方法</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
</code></pre></div></li> <li><p>6.<code>vm._render</code>作用是返回<code>vnode</code>  内部会调用解析好的<code>render</code>方法(<code>vm._renderProxy</code> 和 <code>vm.$createElement</code>)</p></li> <li><p><code>vm.$createElement</code> =&gt; <code>vdom/create-element</code> =&gt; <code>_createElement</code> =&gt;<code>vnode</code></p></li> <li><p>7.<code>vm._update</code> 将<code>vnode</code> 渲染成真实的<code>dom</code>元素</p> <ul><li><code>vm.__patch__</code> 默认会调用 <code>vdom/patch方法</code></li> <li><code>patch</code>方法会根据<code>vm.$el</code>创建虚拟节点和新的节点,映射虚拟节点和新节点的关系</li> <li>递归创建子元素，将子元素插入到新的节点中。最终将新的节点插入到<code>vm.$el</code>的后面</li> <li>删除掉<code>vm.$el</code>对应的节点</li></ul></li></ul> <h3 id="四-数据响应式原理"><a href="#四-数据响应式原理" aria-hidden="true" class="header-anchor">#</a> 四.数据响应式原理</h3> <p>将<code>data</code>对应的数据转化成采用<code>Object.defineProperty</code>来定义</p> <ul><li>1.会执行<code>initState</code>方法 =&gt; <code>initData</code> =&gt; <code>observe</code></li> <li>2.<code>new Observer</code> 收到要观察的数据 =&gt; <code>this.walk</code> =&gt; <code>defineReactive</code> =&gt; 如果观察对象的值是一个对象的话，会递归观察=&gt; 采用<code>Object.defineProperty</code> 来重新定义属性</li> <li>3.默认会先初始化<code>Watcher</code>实例，将此实例放到<code>Dep.target</code>上，并且给每一个属性增加一个<code>dep</code>属性,此<code>dep</code>会将当前的<code>Dep.target</code>存起来。</li> <li>4.每次更新值都会通知对应<code>dep</code>中存放的<code>watcher</code> 让他们调用update方法最终会将要执行的<code>watcher</code>放到<code>queue</code>中，最后调用<code>nextTick(flushSchedulerQueue)</code>方法清空队列,让视图更新</li></ul> <h3 id="五-计算属性的实现"><a href="#五-计算属性的实现" aria-hidden="true" class="header-anchor">#</a> 五.计算属性的实现</h3> <p>默认会创建一个计算属性<code>watcher</code>，当取值时会调用用户定义的计算属性方法,会对依赖的属性取值，此时依赖的属性会将计算属性的<code>watcher</code>收集起来,最后计算属性<code>watcher</code>会将渲染<code>watcher</code>放到对应的每个属性的<code>dep</code>中, 属性变化时会依次执行计算属性<code>watcher</code>和渲染<code>watcher</code></p> <h3 id="六-watch的实现原理"><a href="#六-watch的实现原理" aria-hidden="true" class="header-anchor">#</a> 六.<code>Watch</code>的实现原理</h3> <p>内部调用<code>vm.$watch</code>,默认会创建一个<code>watcher</code>,会将表达式根据<code>.</code>分割,去<code>vm</code>上取值，取值的过程中会将此<code>watcher</code>收集到当前属性的依赖中，属性变化会通知此<code>watcher</code>执行</p> <h3 id="七-dom-diff原理"><a href="#七-dom-diff原理" aria-hidden="true" class="header-anchor">#</a> 七.<code>Dom-Diff</code>原理</h3> <h2 id="总结图"><a href="#总结图" aria-hidden="true" class="header-anchor">#</a> 总结图</h2> <p><img src="/assets/img/vueSource.da03093e.png" alt="vueSource"></p> <h2 id="实现broadcast"><a href="#实现broadcast" aria-hidden="true" class="header-anchor">#</a> 实现broadcast</h2> <h2 id="组件"><a href="#组件" aria-hidden="true" class="header-anchor">#</a> 组件</h2> <ul><li><p>表单组件</p></li> <li><p>异步组件</p></li> <li><p>递归组件</p></li> <li><p>弹框组件</p></li></ul> <h2 id="插件原理"><a href="#插件原理" aria-hidden="true" class="header-anchor">#</a> 插件原理</h2> <h3 id="vue-lazyload组件实现"><a href="#vue-lazyload组件实现" aria-hidden="true" class="header-anchor">#</a> vue-lazyload组件实现</h3> <ul><li>使用</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// main.js</span>
<span class="token comment">// vue-lazyload 图片懒加载 v-lazy</span>
<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> VuelazyLoad <span class="token keyword">from</span> <span class="token string">'./vue-lazyload'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> loading <span class="token keyword">from</span> <span class="token string">'./loading.jpg'</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span>
<span class="token comment">// use方法是一个全局的api 会调用 VuelazyLoad install</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VuelazyLoad<span class="token punctuation">,</span><span class="token punctuation">{</span>
    preLoad<span class="token punctuation">:</span> <span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token comment">// 可见区域的1.3倍</span>
    loading<span class="token punctuation">,</span> <span class="token comment">// loading图</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// use的默认调用就会执行VuelazyLoad的install方法</span>

<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">render</span><span class="token punctuation">:</span><span class="token parameter">h</span><span class="token operator">=&gt;</span><span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>box<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>img in imgs<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>img<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">v-lazy</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>img<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>        
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span><span class="token punctuation">;</span> <span class="token comment">// 基于promise async + await</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>imgs<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// vue的生命周期是同步执行的</span>
       axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'http://www.fullstackjavascript.cn:9999/api/img'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>data<span class="token punctuation">}</span></span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>

           <span class="token keyword">this</span><span class="token punctuation">.</span>imgs <span class="token operator">=</span> data<span class="token punctuation">;</span>
       <span class="token punctuation">}</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
<span class="token selector">.box</span> <span class="token punctuation">{</span>
    <span class="token property">height</span><span class="token punctuation">:</span>300px<span class="token punctuation">;</span>
    <span class="token property">overflow</span><span class="token punctuation">:</span> scroll<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">img</span><span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span>100px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>实现</p> <ul><li>主要做的就是
<ol><li>监控父亲的滚动事件</li> <li>当滚动时候 检测当前的图片是否出现在了可视区域内</li></ol></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// vue-lazyload/index.js</span>
<span class="token comment">/* eslint-disable */</span>
<span class="token keyword">import</span> Lazy <span class="token keyword">from</span> <span class="token string">'./lazy'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token comment">// install 方法中有两个参数 Vue的构造函数</span>
    <span class="token comment">// 希望我们写vue插件的时候 不去依赖vue</span>
    <span class="token function">install</span><span class="token punctuation">(</span><span class="token parameter">Vue<span class="token punctuation">,</span>options</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//_Vue = Vue; // 为了保证和当前用户使用的Vue构造函数是同一个</span>
        <span class="token comment">// vue-lazyload 主要就是提供一个指令</span>
        <span class="token comment">// 1) 可能注册一些全局组件 2） 给vue的原型的扩展属性  3) 可以赋予一些全局指令和过滤器</span>
        <span class="token keyword">const</span> LazyClass <span class="token operator">=</span> <span class="token function">Lazy</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">LazyClass</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>test<span class="token operator">=</span><span class="token string">'xx'</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> lazy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazyClass</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">debugger</span><span class="token punctuation">;</span>
        Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'lazy'</span><span class="token punctuation">,</span><span class="token punctuation">{</span> <span class="token comment">// 只要绑定就回调用</span>
            <span class="token comment">// 保证当前add方法执行的时候 this永远指向lazy实例</span>
            bind<span class="token punctuation">:</span>lazy<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>lazy<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// vue-lazyload/lazy.js</span>
<span class="token comment">/* eslint-disable */</span>
<span class="token comment">// 存放懒加载功能的文件</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>throttle<span class="token punctuation">,</span>debounce<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lodash'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token parameter">Vue</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">ReactiveListener</span><span class="token punctuation">{</span>
        <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>el<span class="token punctuation">,</span>src<span class="token punctuation">,</span>elRenderer<span class="token punctuation">,</span>options<span class="token punctuation">}</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>el <span class="token operator">=</span> el<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>src <span class="token operator">=</span> src<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>elRenderer <span class="token operator">=</span>elRenderer<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>options <span class="token operator">=</span> options<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>loading<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">}</span>

        <span class="token punctuation">}</span>
        <span class="token function">checkInView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 判断是否渲染</span>
            <span class="token keyword">let</span> <span class="token punctuation">{</span>top<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>el<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 高度就是图片的位置</span>
            <span class="token keyword">return</span> top <span class="token operator">&lt;</span> window<span class="token punctuation">.</span>innerHeight <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">.</span>preLoad
        <span class="token punctuation">}</span>
        <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 加载当前的listener</span>
            <span class="token comment">// 开始渲染 渲染前 需要默认渲染loading状态</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">elRenderer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">'loading'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">loadImageAsync</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>src<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>loading <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 加载完毕了</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">elRenderer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">'loaded'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">elRenderer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 异步加载图片</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">function</span> <span class="token function">loadImageAsync</span><span class="token punctuation">(</span><span class="token parameter">src<span class="token punctuation">,</span>resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> image <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        image<span class="token punctuation">.</span>src <span class="token operator">=</span> src<span class="token punctuation">;</span>
        image<span class="token punctuation">.</span>onload <span class="token operator">=</span> resolve<span class="token punctuation">;</span>
        image<span class="token punctuation">.</span>onerror <span class="token operator">=</span> reject
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">LazyClass</span><span class="token punctuation">{</span>
        <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>options <span class="token operator">=</span> options<span class="token punctuation">;</span> <span class="token comment">// 将用户传入的数据保存到当前的实例上</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>listenerQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>bindHandler <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

            <span class="token comment">// 在一段时间内 不停的触发方法</span>
            <span class="token comment">//  防抖(最终触发一次) 节流(默认每隔一段时间执行一次)</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>lazyLoadHandler <span class="token operator">=</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span> 
                <span class="token keyword">let</span> catIn <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>listenerQueue<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">listener</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span>listener<span class="token punctuation">.</span>state<span class="token punctuation">.</span>loading<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span> <span class="token comment">// 如果已经渲染过的图片就不在进行渲染了</span>
                    catIn <span class="token operator">=</span> listener<span class="token punctuation">.</span><span class="token function">checkInView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 判断是否应该渲染</span>
                    catIn <span class="token operator">&amp;&amp;</span> listener<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加载对应的listener</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span>bindings<span class="token punctuation">,</span>vnode</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            
            <span class="token comment">// addEventListener('scroll')  监控当前图片是否在显示区域的范围</span>
            <span class="token comment">// 这里获取不到真实的dom</span>
            Vue<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
                <span class="token keyword">function</span> <span class="token function">scrollParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">let</span> parent <span class="token operator">=</span> el<span class="token punctuation">.</span>parentNode<span class="token punctuation">;</span>
                    <span class="token keyword">while</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">{</span>
                        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token regex">/scroll/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token function">getComputedStyle</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'overflow'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                            <span class="token keyword">return</span> parent<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        parent <span class="token operator">=</span> parent<span class="token punctuation">.</span>parentNode <span class="token comment">// 不停的向上找 找带有overflow的属性</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">return</span> parent
                <span class="token punctuation">}</span>
                <span class="token keyword">let</span> parent <span class="token operator">=</span> <span class="token function">scrollParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 我要判断当前这个图片是否要加载</span>
                <span class="token keyword">let</span> src <span class="token operator">=</span> bindings<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token comment">// 对应的v-lazy的值</span>
                <span class="token keyword">let</span> listener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReactiveListener</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                    el<span class="token punctuation">,</span> <span class="token comment">// 真实的dom</span>
                    src<span class="token punctuation">,</span>
                    elRenderer<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">elRenderer</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    options<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">,</span> <span class="token comment">// {默认会看是渲染loading}</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>listenerQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>bindHandler<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">this</span><span class="token punctuation">.</span>bindHandler <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'绑定一次'</span><span class="token punctuation">)</span>
                    parent<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'scroll'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>lazyLoadHandler<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 滚动时判断</span>
                <span class="token punctuation">}</span>   
               
                <span class="token comment">// 默认需要先进行一次判断 </span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">lazyLoadHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">elRenderer</span><span class="token punctuation">(</span><span class="token parameter">listener<span class="token punctuation">,</span>state</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 渲染当前实例的什么状态</span>
            <span class="token keyword">let</span> <span class="token punctuation">{</span>el<span class="token punctuation">}</span> <span class="token operator">=</span> listener<span class="token punctuation">;</span>
            <span class="token keyword">let</span> src <span class="token operator">=</span> <span class="token string">''</span>
            <span class="token keyword">switch</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">case</span> <span class="token string">'loading'</span><span class="token punctuation">:</span>
                    src <span class="token operator">=</span> listener<span class="token punctuation">.</span>options<span class="token punctuation">.</span>loading <span class="token operator">||</span> <span class="token string">''</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token keyword">case</span> <span class="token string">'error'</span><span class="token punctuation">:</span>
                    src <span class="token operator">=</span> listener<span class="token punctuation">.</span>options<span class="token punctuation">.</span>error <span class="token operator">||</span> <span class="token string">''</span>
                <span class="token keyword">default</span><span class="token punctuation">:</span>
                    src <span class="token operator">=</span> listener<span class="token punctuation">.</span>src
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">,</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="js垃圾收集"><a href="#js垃圾收集" aria-hidden="true" class="header-anchor">#</a> JS垃圾收集</h3> <h4 id="简介"><a href="#简介" aria-hidden="true" class="header-anchor">#</a> 简介</h4> <ul><li>js使用自动内存管理，这被称为“垃圾回收机制”，优点是可以简化开发，节省代码。缺点是无法完整掌握内存的分配和回收过程</li> <li>内存有限制
<ul><li>因为V8垃圾收集工作原理导致，1.4g内存完成一次垃圾收集需要1s以上，暂停期间内，应用性能和响应能力都会下降</li></ul></li> <li>JS对象通过V8引擎来分配内存</li> <li><code>process.memoryUsage</code>返回一个对象，包含了Node进程的内存占用信息
<ul><li>rss:所有内存占用，包括指令区和堆栈(代码区域，栈[本地变量和指针，基本类型]，堆[对象，闭包]，堆还分为使用到的堆和未使用的)</li> <li>heapTotal:“堆”占用的内存，包括用到的和没用到的</li> <li>heapUsed:“堆”用到的内存</li> <li>external:V8引擎内部的C++对象占用的内存</li></ul></li></ul> <h4 id="v8的垃圾回收机制"><a href="#v8的垃圾回收机制" aria-hidden="true" class="header-anchor">#</a> V8的垃圾回收机制</h4> <ul><li>按存活时间分为新生代和老生代</li></ul> <h3 id="函数柯里化"><a href="#函数柯里化" aria-hidden="true" class="header-anchor">#</a> 函数柯里化</h3> <p>柯里化，英语：Currying(果然是满满的英译中的既视感)，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p> <ul><li>例子</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 普通的add函数</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y
<span class="token punctuation">}</span>

<span class="token comment">// Currying后</span>
<span class="token keyword">function</span> <span class="token function">curryingAdd</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> x <span class="token operator">+</span> y
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>           <span class="token comment">// 3</span>
<span class="token function">curryingAdd</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>   <span class="token comment">// 3</span>
</code></pre></div><p>实际上就是把add函数的x，y两个参数变成了先用一个函数接收x然后返回一个函数去处理y参数。现在思路应该就比较清晰了，就是只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p> <h4 id="currying好处"><a href="#currying好处" aria-hidden="true" class="header-anchor">#</a> Currying好处</h4> <ol><li>参数复用</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 正常正则验证字符串 reg.test(txt)</span>

<span class="token comment">// 函数封装后</span>
<span class="token keyword">function</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token parameter">reg<span class="token punctuation">,</span> txt</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>txt<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">check</span><span class="token punctuation">(</span><span class="token regex">/\d+/g</span><span class="token punctuation">,</span> <span class="token string">'test'</span><span class="token punctuation">)</span>       <span class="token comment">//false</span>
<span class="token function">check</span><span class="token punctuation">(</span><span class="token regex">/[a-z]+/g</span><span class="token punctuation">,</span> <span class="token string">'test'</span><span class="token punctuation">)</span>    <span class="token comment">//true</span>

<span class="token comment">// Currying后</span>
<span class="token keyword">function</span> <span class="token function">curryingCheck</span><span class="token punctuation">(</span><span class="token parameter">reg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">txt</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>txt<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> hasNumber <span class="token operator">=</span> <span class="token function">curryingCheck</span><span class="token punctuation">(</span><span class="token regex">/\d+/g</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> hasLetter <span class="token operator">=</span> <span class="token function">curryingCheck</span><span class="token punctuation">(</span><span class="token regex">/[a-z]+/g</span><span class="token punctuation">)</span>

<span class="token function">hasNumber</span><span class="token punctuation">(</span><span class="token string">'test1'</span><span class="token punctuation">)</span>      <span class="token comment">// true</span>
<span class="token function">hasNumber</span><span class="token punctuation">(</span><span class="token string">'testtest'</span><span class="token punctuation">)</span>   <span class="token comment">// false</span>
<span class="token function">hasLetter</span><span class="token punctuation">(</span><span class="token string">'21212'</span><span class="token punctuation">)</span>      <span class="token comment">// false</span>
</code></pre></div><p>上面的示例是一个正则的校验，正常来说直接调用check函数就可以了，但是如果我有很多地方都要校验是否有数字，其实就是需要将第一个参数reg进行复用，这样别的地方就能够直接调用hasNumber，hasLetter等函数，让参数能够复用，调用起来也更方便。</p> <ol start="2"><li>提前确认</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">on</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> event<span class="token punctuation">,</span> handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>addEventListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>element <span class="token operator">&amp;&amp;</span> event <span class="token operator">&amp;&amp;</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>element <span class="token operator">&amp;&amp;</span> event <span class="token operator">&amp;&amp;</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            element<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">'on'</span> <span class="token operator">+</span> event<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> on <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>addEventListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> event<span class="token punctuation">,</span> handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>element <span class="token operator">&amp;&amp;</span> event <span class="token operator">&amp;&amp;</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> event<span class="token punctuation">,</span> handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>element <span class="token operator">&amp;&amp;</span> event <span class="token operator">&amp;&amp;</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                element<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">'on'</span> <span class="token operator">+</span> event<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//换一种写法可能比较好理解一点，上面就是把isSupport这个参数给先确定下来了</span>
<span class="token keyword">var</span> <span class="token function-variable function">on</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">isSupport<span class="token punctuation">,</span> element<span class="token punctuation">,</span> event<span class="token punctuation">,</span> handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    isSupport <span class="token operator">=</span> isSupport <span class="token operator">||</span> document<span class="token punctuation">.</span>addEventListener<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isSupport<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> element<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">'on'</span> <span class="token operator">+</span> event<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们在做项目的过程中，封装一些dom操作可以说再常见不过，上面第一种写法也是比较常见，但是我们看看第二种写法，它相对一第一种写法就是自执行然后返回一个新的函数，这样其实就是提前确定了会走哪一个方法，避免每次都进行判断。</p> <ol start="3"><li>延迟运行</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> _this <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
 
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">_this</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>像我们js中经常使用的bind，实现的机制就是Currying.</p> <h4 id="通用的封装方法"><a href="#通用的封装方法" aria-hidden="true" class="header-anchor">#</a> 通用的封装方法</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 初步封装</span>
<span class="token keyword">var</span> <span class="token function-variable function">currying</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// args 获取第一个方法内的全部参数</span>
    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将后面方法里的全部参数和args进行合并</span>
        <span class="token keyword">var</span> newArgs <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 把合并后的参数通过apply作为fn的参数并执行</span>
        <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newArgs<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这边首先是初步封装,通过闭包把初步参数给保存下来，然后通过获取剩下的arguments进行拼接，最后执行需要currying的函数。</p> <p>但是好像还有些什么缺陷，这样返回的话其实只能多扩展一个参数，currying(a)(b)(c)这样的话，貌似就不支持了（不支持多参数调用），一般这种情况都会想到使用递归再进行封装一层。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 支持多参数传递</span>
<span class="token keyword">function</span> <span class="token function">progressCurrying</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">var</span> _this <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">var</span> len <span class="token operator">=</span> fn<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">var</span> args <span class="token operator">=</span> args <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> _args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> _args<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 如果参数个数小于最初的fn.length，则递归调用，继续收集参数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_args<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">progressCurrying</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>_this<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> _args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 参数收集完毕，则执行fn</span>
        <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> _args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这边其实是在初步的基础上，加上了递归的调用，只要参数个数小于最初的fn.length，就会继续执递归。</p> <h4 id="curry的性能"><a href="#curry的性能" aria-hidden="true" class="header-anchor">#</a> curry的性能</h4> <ul><li>存取arguments对象通常要比存取命名参数要慢一点</li> <li>一些老版本的浏览器在arguments.length的实现上是相当慢的</li> <li>使用fn.apply( … ) 和 fn.call( … )通常比直接调用fn( … ) 稍微慢点</li> <li>创建大量嵌套作用域和闭包函数会带来花销，无论是在内存还是速度上</li></ul> <p>其实在大部分应用中，主要的性能瓶颈是在操作DOM节点上，这js的性能损耗基本是可以忽略不计的，所以curry是可以直接放心的使用。</p> <h4 id="【经典面试题】"><a href="#【经典面试题】" aria-hidden="true" class="header-anchor">#</a> 【经典面试题】</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 实现一个add方法，使计算结果能够满足如下预期：</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span>
    <span class="token keyword">var</span> _args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span>
    <span class="token keyword">var</span> <span class="token function-variable function">_adder</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        _args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> _adder<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span>
    _adder<span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> _args<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> _adder<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>                <span class="token comment">// 6</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>             <span class="token comment">// 10</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>          <span class="token comment">// 15</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token comment">// 9</span>
</code></pre></div></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Frontend/vue.html" class="prev">
          【7. vue】
        </a></span> <span class="next"><a href="/Frontend/react.html">
          React
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.54eabcd6.js" defer></script><script src="/assets/js/16.5961a583.js" defer></script>
  </body>
</html>
